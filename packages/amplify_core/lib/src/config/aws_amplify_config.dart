// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

import 'dart:convert';

import 'package:amplify_core/amplify_config.dart';
import 'package:amplify_core/amplify_core.dart' as core;
import 'package:amplify_core/src/generated/src/amplify_configuration_service/common/serializers.dart';
import 'package:aws_common/aws_common.dart';
import 'package:built_value/built_value.dart';
import 'package:built_value/serializer.dart';
import 'package:built_value/standard_json_plugin.dart';
import 'package:collection/collection.dart';
import 'package:meta/meta.dart';
import 'package:smithy/smithy.dart' hide Serializer;

part 'aws_amplify_config.g.dart';

/// {@template amplify_core.aws_amplify_config}
/// A strongly-typed Amplify configuration.
///
/// ## Parsing a CLI-generated configuration
/// To parse a configuration generated by the CLI, use [AWSAmplifyConfig.parse].
///
/// <?code-excerpt "doc/lib/config.dart" region="imports"?>
/// ```dart
/// import 'package:amplify_flutter/amplify_flutter.dart' hide AWSApiConfig;
/// ```
/// <?code-excerpt "doc/lib/config.dart" region="cli-imports"?>
/// ```dart
/// import 'amplifyconfiguration.dart';
/// ```
/// <?code-excerpt "doc/lib/config.dart" region="parse"?>
/// ```dart
/// void parseCliConfig() {
///   final cliConfig = AWSAmplifyConfig.parse(amplifyconfig);
///   safePrint(cliConfig);
/// }
/// ```
///
/// ## Modifying a CLI-generated configuration
/// Sometimes, the configuration generated by the CLI is incomplete. Perhaps you've
/// modified values in your backend which are not reflected in the CLI, or you need
/// to add resources which the CLI is not aware of.
///
/// To update existing values in the config, use the `update*` methods. For example,
/// to update a user pool configuration, use [updateUserPool].
///
/// <?code-excerpt "doc/lib/config.dart" region="imports"?>
/// ```dart
/// import 'package:amplify_flutter/amplify_flutter.dart' hide AWSApiConfig;
/// ```
/// <?code-excerpt "doc/lib/config.dart" region="cli-imports"?>
/// ```dart
/// import 'amplifyconfiguration.dart';
/// ```
/// <?code-excerpt "doc/lib/config.dart" region="update-user-pool"?>
/// ```dart
/// // Updates the user pool configuration to use `CUSTOM_AUTH_WITH_SRP` as the
/// // default authentication flow.
/// AWSAmplifyConfig updateUserPool() {
///   return AWSAmplifyConfig.parse(amplifyconfig).updateUserPool(
///     (userPool) =>
///         userPool.authFlowType = AuthenticationFlowType.customAuthWithSrp,
///   );
/// }
/// ```
///
/// To add a resource, use the `with*` methods. For example, to add a user pool to
/// a configuration which does not already have one, use [withUserPool].
///
/// <?code-excerpt "doc/lib/config.dart" region="imports"?>
/// ```dart
/// import 'package:amplify_flutter/amplify_flutter.dart' hide AWSApiConfig;
/// ```
/// <?code-excerpt "doc/lib/config.dart" region="cli-imports"?>
/// ```dart
/// import 'amplifyconfiguration.dart';
/// ```
/// <?code-excerpt "doc/lib/config.dart" region="add-user-pool"?>
/// ```dart
/// // Adds a user pool to the configuration.
/// //
/// // User pool values may be obtained from the output of an infrastructure-as-code
/// // solution (e.g. CloudFormation, CDK, or Terraform) or by viewing the AWS console.
/// AWSAmplifyConfig addUserPool() {
///   return AWSAmplifyConfig.parse(amplifyconfig).withUserPool(
///     poolId: '<USER_POOL_ID>',
///     region: '<USER_POOL_REGION>',
///     clientId: '<USER_POOL_CLIENT_ID>',
///   );
/// }
/// ```
///
/// ## Building a configuration from scratch
/// If you're not using the Amplify CLI, then you won't have a configuration file
/// which you can parse. In this case, you can construct an [AWSAmplifyConfig] from
/// scratch.
///
/// <?code-excerpt "doc/lib/config.dart" region="imports"?>
/// ```dart
/// import 'package:amplify_flutter/amplify_flutter.dart' hide AWSApiConfig;
/// ```
/// <?code-excerpt "doc/lib/config.dart" region="config-from-scratch"?>
/// ```dart
/// // Creates an AWSAmplifyConfig with a user pool and a GraphQL API.
/// AWSAmplifyConfig buildConfig() {
///   return AWSAmplifyConfig(
///     api: AWSApiConfig(
///       apis: {
///         '<API_NAME>': ApiEndpointConfig.appSync(
///           endpoint: Uri.parse(
///             'https://xxxxxx.appsync-api.us-east-1.amazonaws.com/graphql',
///           ),
///           region: 'us-east-1',
///           authMode: const AWSApiAuthorizationMode.apiKey(
///             'da2-xxxxxxxxxxxxxxxxxxxxxxxxxx',
///           ),
///           additionalAuthModes: [
///             const AWSApiAuthorizationMode.userPools(),
///           ],
///         ),
///       },
///     ),
///     auth: AuthConfig.cognito(
///       userPool: AuthUserPoolConfig(
///         poolId: '<USER_POOL_ID>',
///         region: '<USER_POOL_REGION>',
///         clientId: '<USER_POOL_CLIENT_ID>',
///       ),
///     ),
///   );
/// }
/// ```
/// {@endtemplate}
@experimental
abstract class AWSAmplifyConfig
    with
        AWSEquatable<AWSAmplifyConfig>,
        AWSSerializable<Map<String, Object?>>,
        AWSDebuggable,
        AWSLoggerMixin
    implements Built<AWSAmplifyConfig, AWSAmplifyConfigBuilder> {
  /// {@macro amplify_core.aws_amplify_config}
  @experimental
  factory AWSAmplifyConfig({
    AnalyticsConfig? analytics,
    ApiConfig? api,
    AuthConfig? auth,
    LoggingConfig? logging,
    NotificationsConfig? notifications,
    StorageConfig? storage,
  }) {
    return _$AWSAmplifyConfig._(
      analytics: analytics,
      api: api,
      auth: auth,
      logging: logging,
      notifications: notifications,
      storage: storage,
    );
  }

  /// Builds an [AWSAmplifyConfig] using an [AWSAmplifyConfigBuilder].
  @experimental
  factory AWSAmplifyConfig.build([
    void Function(AWSAmplifyConfigBuilder) updates,
  ]) = _$AWSAmplifyConfig;

  /// Creates an [AWSAmplifyConfig] from an [core.AmplifyConfig].
  @experimental
  factory AWSAmplifyConfig.from(core.AmplifyConfig config) {
    return AWSAmplifyConfig.build((b) {
      if (config.analytics?.awsPlugin case final analyticsConfig?) {
        b.analytics = AnalyticsConfig.pinpoint(
          appId: analyticsConfig.pinpointAnalytics.appId,
          region: analyticsConfig.pinpointAnalytics.region,
          autoFlushEventsInterval: analyticsConfig.autoFlushEventsInterval,
        );
      }
      if (config.api?.awsPlugin case final apiConfig?) {
        final endpoints = Map.of(apiConfig.endpoints);
        while (endpoints.isNotEmpty) {
          final apiName = endpoints.keys.first;
          final cliEndpoint = endpoints.remove(apiName)!;
          final defaultAuthMode = cliEndpoint.defaultAuthMode;
          final endpoint = Uri.parse(cliEndpoint.endpoint);
          final config =
              switch ((cliEndpoint.endpointType, cliEndpoint.region)) {
            (core.EndpointType.graphQL, final region?) =>
              ApiEndpointConfig.appSync(
                name: apiName,
                endpoint: endpoint,
                region: region,
                authMode: defaultAuthMode,
              ),
            (core.EndpointType.rest, final region?) =>
              ApiEndpointConfig.apiGateway(
                name: apiName,
                endpoint: endpoint,
                region: region,
                authMode: defaultAuthMode,
              ),
            (core.EndpointType.rest, null) => ApiEndpointConfig.rest(
                name: apiName,
                endpoint: endpoint,
              ),
            _ => throw ArgumentError(
                'Invalid endpoint configuration: $cliEndpoint',
              ),
          };
          b.api.endpoints.add(config);
        }
      }
      if (config.auth?.awsPlugin case final authConfig?) {
        b.auth = AuthConfigCognito$(
          AuthCognitoConfig.build((b) {
            if (authConfig.cognitoUserPool?.default$
                case final userPoolConfig?) {
              b.userPool
                ..poolId = userPoolConfig.poolId
                ..region = userPoolConfig.region
                ..clientId = userPoolConfig.appClientId
                ..clientSecret = userPoolConfig.appClientSecret
                ..endpoint = userPoolConfig.endpoint?.let(Uri.parse);

              if (authConfig.auth?.default$ case final cliAuthConfig?) {
                b.userPool
                  ..authFlowType = cliAuthConfig.authenticationFlowType
                  ..mfaConfiguration = switch ((
                    cliAuthConfig.mfaConfiguration,
                    cliAuthConfig.mfaTypes
                  )) {
                    (final mfaConfig?, final mfaTypes?) =>
                      AuthMfaConfigurationBuilder()
                        ..enforcementLevel = mfaConfig
                        ..sms = mfaTypes.contains(MfaType.sms)
                        ..totp = mfaTypes.contains(MfaType.totp),
                    _ => null,
                  }
                  ..passwordPolicy =
                      cliAuthConfig.passwordProtectionSettings?.let(
                    (passwordSettings) => AuthPasswordPolicyBuilder()
                      ..minLength = passwordSettings.passwordPolicyMinLength
                      ..requiresLowercase =
                          passwordSettings.passwordPolicyCharacters.contains(
                        core.PasswordPolicyCharacters.requiresLowercase,
                      )
                      ..requiresUppercase =
                          passwordSettings.passwordPolicyCharacters.contains(
                        core.PasswordPolicyCharacters.requiresUppercase,
                      )
                      ..requiresNumbers =
                          passwordSettings.passwordPolicyCharacters.contains(
                        core.PasswordPolicyCharacters.requiresNumbers,
                      )
                      ..requiresSymbols =
                          passwordSettings.passwordPolicyCharacters.contains(
                        core.PasswordPolicyCharacters.requiresSymbols,
                      ),
                  );

                cliAuthConfig.socialProviders?.let((socialProviders) {
                  b.userPool.socialProviders.addAll([
                    for (final socialProvider in socialProviders)
                      switch (socialProvider) {
                        core.SocialProvider.amazon => AuthProvider.amazon,
                        core.SocialProvider.apple => AuthProvider.apple,
                        core.SocialProvider.facebook => AuthProvider.facebook,
                        core.SocialProvider.google => AuthProvider.google,
                      },
                  ]);
                });

                cliAuthConfig.usernameAttributes?.let((usernameAttributes) {
                  b.userPool.usernameAttributes.addAll([
                    for (final usernameAttribute in usernameAttributes)
                      switch (usernameAttribute) {
                        CognitoUserAttributeKey.email =>
                          AuthUsernameAttribute.email,
                        CognitoUserAttributeKey.phoneNumber =>
                          AuthUsernameAttribute.phoneNumber,
                        _ => throw ArgumentError(
                            'Invalid username attribute: $usernameAttribute',
                          ),
                      },
                  ]);
                });

                cliAuthConfig.verificationMechanisms
                    ?.let(b.userPool.verificationMechanisms.addAll);
                cliAuthConfig.signupAttributes
                    ?.let(b.userPool.signUpAttributes.addAll);
              }

              final hostedUiConfig =
                  authConfig.auth?.default$?.oAuth ?? userPoolConfig.hostedUI;
              if (hostedUiConfig != null) {
                b.userPool.hostedUi
                  ..clientId = hostedUiConfig.appClientId
                  ..clientSecret = hostedUiConfig.appClientSecret
                  ..domainName = hostedUiConfig.webDomain
                  ..signInRedirectUris.addAll(hostedUiConfig.signInRedirectUris)
                  ..signOutRedirectUris
                      .addAll(hostedUiConfig.signOutRedirectUris)
                  ..scopes.addAll(hostedUiConfig.scopes)
                  ..signInUri = hostedUiConfig.signInUri?.let(
                    (uri) => Uri.parse(uri).replace(
                      queryParameters: hostedUiConfig.signInUriQueryParameters,
                    ),
                  )
                  ..signOutUri = hostedUiConfig.signOutUri?.let(
                    (uri) => Uri.parse(uri).replace(
                      queryParameters: hostedUiConfig.signOutUriQueryParameters,
                    ),
                  )
                  ..tokenUri = hostedUiConfig.tokenUri?.let(
                    (uri) => Uri.parse(uri).replace(
                      queryParameters: hostedUiConfig.tokenUriQueryParameters,
                    ),
                  );
              }

              authConfig.pinpointAnalytics?.default$?.let(
                (pinpointConfig) => b.userPool.pinpointConfig
                  ..appId = pinpointConfig.appId
                  ..region = pinpointConfig.region,
              );
            }
            if (authConfig.credentialsProvider?.default$
                case final identityPoolConfig?) {
              b.identityPool
                ..poolId = identityPoolConfig.poolId
                ..region = identityPoolConfig.region;
            }
          }),
        );
      }
      if (config.logging?.awsPlugin case final loggingConfig?) {
        b.logging = LoggingConfig.cloudWatch(
          enable: loggingConfig.enable,
          logGroupName: loggingConfig.logGroupName,
          region: loggingConfig.region,
          localStoreMaxSize: LocalStorageSize.MB(
            loggingConfig.localStoreMaxSizeInMB,
          ),
          flushInterval: Duration(
            seconds: loggingConfig.flushIntervalInSeconds,
          ),
          defaultRemoteConfiguration:
              loggingConfig.defaultRemoteConfiguration?.let(
            (remoteConfig) => LoggingRemoteConfig(
              endpoint: Uri.parse(remoteConfig.endpoint),
              refreshInterval: Duration(
                seconds: remoteConfig.refreshIntervalInSeconds,
              ),
            ),
          ),
          loggingConstraints: loggingConfig.loggingConstraints?.let(
            (constraints) => AmplifyLoggingConstraints(
              defaultLogLevel: constraints.defaultLogLevel,
              categoryLogLevel: constraints.categoryLogLevel,
              userLogLevel: constraints.userLogLevel,
            ),
          ),
        );
      }
      if (config.notifications?.awsPlugin case final notificationsConfig?) {
        b.notifications.push = PushNotificationsConfig.pinpoint(
          appId: notificationsConfig.appId,
          region: notificationsConfig.region,
        );
      }
      if (config.storage?.awsPlugin case final storageConfig?) {
        b.storage = StorageConfig.s3(
          buckets: [
            StorageS3Bucket(
              bucketName: storageConfig.bucket,
              region: storageConfig.region,
              defaultAccessLevel: storageConfig.defaultAccessLevel,
            ),
          ],
        );
      }
    });
  }

  /// Parses an Amplify configuration from a generated `amplifyconfiguration.dart`
  /// file.
  @experimental
  factory AWSAmplifyConfig.parse(String amplifyconfig) {
    final config = core.AmplifyConfig.fromJson(
      jsonDecode(amplifyconfig) as Map<String, dynamic>,
    );
    return AWSAmplifyConfig.from(config);
  }

  const AWSAmplifyConfig._();

  static Serializer<AWSAmplifyConfig> get serializer =>
      _$aWSAmplifyConfigSerializer;

  AnalyticsConfig? get analytics;
  ApiConfig? get api;
  AuthConfig? get auth;
  LoggingConfig? get logging;
  NotificationsConfig? get notifications;
  StorageConfig? get storage;

  /// Adds a user pool to the configuration or replaces the existing one.
  @useResult
  AWSAmplifyConfig withUserPool({
    required String poolId,
    required String region,
    required String clientId,
    String? clientSecret,
    Uri? endpoint,
    AuthenticationFlowType? authFlowType,
    List<AuthProvider>? socialProviders,
    List<AuthUsernameAttribute>? usernameAttributes,
    List<CognitoUserAttributeKey>? signUpAttributes,
    AnalyticsPinpointConfig? pinpointConfig,
    AuthPasswordPolicy? passwordPolicy,
    AuthMfaConfiguration? mfaConfiguration,
    List<CognitoUserAttributeKey>? verificationMechanisms,
    AuthHostedUiConfig? hostedUi,
  }) =>
      rebuild((b) {
        final userPoolConfig = AuthUserPoolConfig(
          poolId: poolId,
          region: region,
          clientId: clientId,
          clientSecret: clientSecret,
          endpoint: endpoint,
          authFlowType: authFlowType,
          socialProviders: socialProviders,
          usernameAttributes: usernameAttributes,
          signUpAttributes: signUpAttributes,
          pinpointConfig: pinpointConfig,
          passwordPolicy: passwordPolicy,
          mfaConfiguration: mfaConfiguration,
          verificationMechanisms: verificationMechanisms,
          hostedUi: hostedUi,
        );
        switch (b.auth?.value) {
          case AuthCognitoConfig(:final identityPool):
            b.auth = AuthConfig.cognito(
              userPool: userPoolConfig,
              identityPool: identityPool,
            );
          case null:
            b.auth = AuthConfig.cognito(
              userPool: userPoolConfig,
            );
          case final existing:
            throw ArgumentError(
              'Config already contains a non-Cognito Auth config: $existing',
            );
        }
      });

  /// Adds a user pool to the configuration or updates the existing one.
  @useResult
  AWSAmplifyConfig updateUserPool(
    void Function(AuthUserPoolConfigBuilder userPool) builder,
  ) =>
      rebuild((b) {
        switch (b.auth?.value) {
          case AuthCognitoConfig(:final userPool, :final identityPool):
            b.auth = AuthConfig.cognito(
              userPool: userPool?.rebuild(builder) ??
                  AuthUserPoolConfig.build(builder),
              identityPool: identityPool,
            );
          case null:
            b.auth = AuthConfig.cognito(
              userPool: AuthUserPoolConfig.build(builder),
            );
          case final existing:
            throw ArgumentError(
              'Config already contains a non-Cognito Auth config: $existing',
            );
        }
      });

  /// Adds an identity pool to the configuration or replaces the existing one.
  @useResult
  AWSAmplifyConfig withIdentityPool({
    required String poolId,
    required String region,
  }) =>
      rebuild((b) {
        final identityPoolConfig = AuthIdentityPoolConfig(
          poolId: poolId,
          region: region,
        );
        switch (b.auth?.value) {
          case AuthCognitoConfig(:final userPool):
            b.auth = AuthConfig.cognito(
              userPool: userPool,
              identityPool: identityPoolConfig,
            );
          case null:
            b.auth = AuthConfig.cognito(
              identityPool: identityPoolConfig,
            );
          case final existing:
            throw ArgumentError(
              'Config already contains a non-Cognito Auth config: $existing',
            );
        }
      });

  /// Adds an identity pool to the configuration or updates the existing one.
  @useResult
  AWSAmplifyConfig updateIdentityPool(
    void Function(AuthIdentityPoolConfigBuilder identityPool) builder,
  ) =>
      rebuild((b) {
        switch (b.auth?.value) {
          case AuthCognitoConfig(:final userPool, :final identityPool):
            b.auth = AuthConfig.cognito(
              userPool: userPool,
              identityPool: identityPool?.rebuild(builder) ??
                  AuthIdentityPoolConfig.build(builder),
            );
          case null:
            b.auth = AuthConfig.cognito(
              identityPool: AuthIdentityPoolConfig.build(builder),
            );
          case final existing:
            throw ArgumentError(
              'Config already contains a non-Cognito Auth config: $existing',
            );
        }
      });

  /// Adds a GraphQL API to the configuration or replaces the existing one.
  @useResult
  AWSAmplifyConfig withGraphQlApi(
    String apiName, {
    required Uri endpoint,
    required String region,
    required ApiAuthorizationMode authMode,
    List<ApiAuthorizationMode> additionalAuthModes = const [],
  }) =>
      rebuild((b) {
        final endpointConfig = ApiEndpointConfig.appSync(
          name: apiName,
          endpoint: endpoint,
          region: region,
          authMode: authMode,
          additionalAuthModes: additionalAuthModes,
        );
        final existingApi = b.api.endpoints.build().firstWhereOrNull(
              (api) =>
                  apiName ==
                  switch (api.value) {
                    ApiGatewayEndpointConfig(:final name) ||
                    AppSyncEndpointConfig(:final name) ||
                    RestEndpointConfig(:final name) =>
                      name,
                    _ => null,
                  },
            );
        b.api.endpoints
          ..remove(existingApi)
          ..add(endpointConfig);
      });

  /// Adds a GraphQL API to the configuration or updates the existing one.
  @useResult
  AWSAmplifyConfig updateGraphQlApi(
    String apiName,
    void Function(AppSyncEndpointConfigBuilder api) builder,
  ) =>
      rebuild((b) {
        final existingApi = b.api.endpoints.build().firstWhereOrNull(
              (api) =>
                  apiName ==
                  switch (api.value) {
                    ApiGatewayEndpointConfig(:final name) ||
                    AppSyncEndpointConfig(:final name) ||
                    RestEndpointConfig(:final name) =>
                      name,
                    _ => null,
                  },
            );
        final newApi = switch (existingApi?.value) {
          null => ApiEndpointConfigAppSync$(
              AppSyncEndpointConfig.build((b) {
                b.name = apiName;
                builder(b);
              }),
            ),
          final AppSyncEndpointConfig appSync => ApiEndpointConfigAppSync$(
              appSync.rebuild(builder),
            ),
          final nonAppSyncEndpoint => throw ArgumentError(
              'A non-AppSync endpoint is already registered for $apiName: $nonAppSyncEndpoint',
            ),
        };
        b.api.endpoints
          ..remove(existingApi)
          ..add(newApi);
      });

  /// Adds a REST API to the configuration or replaces the existing one.
  @useResult
  AWSAmplifyConfig withRestApi(
    String apiName, {
    required Uri endpoint,
    required String region,
    required ApiAuthorizationMode authMode,
  }) =>
      rebuild((b) {
        final endpointConfig = ApiEndpointConfig.apiGateway(
          name: apiName,
          endpoint: endpoint,
          region: region,
          authMode: authMode,
        );
        final existingApi = b.api.endpoints.build().firstWhereOrNull(
              (api) =>
                  apiName ==
                  switch (api.value) {
                    ApiGatewayEndpointConfig(:final name) ||
                    AppSyncEndpointConfig(:final name) ||
                    RestEndpointConfig(:final name) =>
                      name,
                    _ => null,
                  },
            );
        b.api.endpoints
          ..remove(existingApi)
          ..add(endpointConfig);
      });

  /// Adds a REST API to the configuration or updates the existing one.
  @useResult
  AWSAmplifyConfig updateRestApi(
    String apiName,
    void Function(ApiGatewayEndpointConfigBuilder api) builder,
  ) =>
      rebuild((b) {
        final existingApi = b.api.endpoints.build().firstWhereOrNull(
              (api) =>
                  apiName ==
                  switch (api.value) {
                    ApiGatewayEndpointConfig(:final name) ||
                    AppSyncEndpointConfig(:final name) ||
                    RestEndpointConfig(:final name) =>
                      name,
                    _ => null,
                  },
            );
        final newApi = switch (existingApi?.value) {
          null => ApiEndpointConfigApiGateway$(
              ApiGatewayEndpointConfig.build((b) {
                b.name = apiName;
                builder(b);
              }),
            ),
          final ApiGatewayEndpointConfig apiGateway =>
            ApiEndpointConfigApiGateway$(
              apiGateway.rebuild(builder),
            ),
          final nonApiGatewayEndpoint => throw ArgumentError(
              'A non-API Gateway endpoint is already registered for $apiName: $nonApiGatewayEndpoint',
            ),
        };
        b.api.endpoints
          ..remove(existingApi)
          ..add(newApi);
      });

  /// Adds a Pinpoint Analytics project to the configuration or replaces the existing one.
  @useResult
  AWSAmplifyConfig withAnalytics({
    required String appId,
    required String region,
    Duration autoFlushEventsInterval = const Duration(seconds: 30),
  }) =>
      rebuild((b) {
        b.analytics = AnalyticsConfig.pinpoint(
          appId: appId,
          region: region,
          autoFlushEventsInterval: autoFlushEventsInterval,
        );
      });

  /// Adds a Pinpoint Analytics project to the configuration or updates the existing one.
  @useResult
  AWSAmplifyConfig updateAnalytics(
    void Function(AnalyticsPinpointConfigBuilder pinpoint) builder,
  ) =>
      rebuild((b) {
        switch (b.analytics) {
          case AnalyticsConfigPinpoint$(:final pinpoint):
            return b.analytics = AnalyticsConfigPinpoint$(
              pinpoint.rebuild(builder),
            );
          case null:
            return b.analytics = AnalyticsConfigPinpoint$(
              AnalyticsPinpointConfig.build(builder),
            );
          case final nonPinpointResource:
            throw ArgumentError(
              'A non-Pinpoint analytics resource already exists: $nonPinpointResource',
            );
        }
      });

  /// Adds a CloudWatch log group to the configuration or replaces the existing one.
  @useResult
  AWSAmplifyConfig withLogging({
    required String logGroupName,
    required String region,
    bool enable = true,
    LocalStorageSize localStoreMaxSize = const LocalStorageSize.MB(5),
    Duration flushInterval = const Duration(seconds: 60),
    LoggingRemoteConfig? defaultRemoteConfiguration,
    AmplifyLoggingConstraints? loggingConstraints,
  }) =>
      rebuild((b) {
        b.logging = LoggingConfig.cloudWatch(
          logGroupName: logGroupName,
          region: region,
          enable: enable,
          localStoreMaxSize: localStoreMaxSize,
          flushInterval: flushInterval,
          defaultRemoteConfiguration: defaultRemoteConfiguration,
          loggingConstraints: loggingConstraints,
        );
      });

  /// Adds a CloudWatch log group to the configuration or updates the existing one.
  @useResult
  AWSAmplifyConfig updateLogging(
    void Function(LoggingCloudWatchConfigBuilder cloudWatch) builder,
  ) =>
      rebuild((b) {
        switch (b.logging) {
          case LoggingConfigCloudWatch$(:final cloudWatch):
            return b.logging = LoggingConfigCloudWatch$(
              cloudWatch.rebuild(builder),
            );
          case null:
            return b.logging = LoggingConfigCloudWatch$(
              LoggingCloudWatchConfig.build(builder),
            );
          case final nonCloudWatchConfig:
            throw ArgumentError(
              'A non-CloudWatch config is already present: $nonCloudWatchConfig',
            );
        }
      });

  /// Adds a Pinpoint Push Notifications project to the configuration or replaces the existing one.
  @useResult
  AWSAmplifyConfig withPushNotifications({
    required String appId,
    required String region,
  }) =>
      rebuild((b) {
        b.notifications.push = PushNotificationsConfig.pinpoint(
          appId: appId,
          region: region,
        );
      });

  /// Adds a Pinpoint Push Notifications project to the configuration or updates the existing one.
  @useResult
  AWSAmplifyConfig updatePushNotifications(
    void Function(PushNotificationsPinpointConfigBuilder push) builder,
  ) =>
      rebuild((b) {
        switch (b.notifications.push) {
          case PushNotificationsConfigPinpoint$(:final pinpoint):
            b.notifications.push = PushNotificationsConfigPinpoint$(
              pinpoint.rebuild(builder),
            );
          case null:
            b.notifications.push = PushNotificationsConfigPinpoint$(
              PushNotificationsPinpointConfig.build(builder),
            );
          case final nonPinpointResource:
            throw ArgumentError(
              'A non-Pinpoint push notifications resource already exists: $nonPinpointResource',
            );
        }
      });

  /// Adds an S3 storage bucket with name [bucketName] or replaces the existing one.
  @useResult
  AWSAmplifyConfig withStorageBucket({
    required String bucketName,
    required String region,
    StorageAccessLevel defaultAccessLevel = StorageAccessLevel.guest,
  }) =>
      rebuild((b) {
        final bucketConfig = StorageS3Bucket(
          bucketName: bucketName,
          region: region,
          defaultAccessLevel: defaultAccessLevel,
        );
        switch (b.storage) {
          case StorageConfigS3$(:final s3):
            return b.storage = StorageConfigS3$(
              s3.rebuild((s3) {
                s3.buckets
                  ..removeWhere((bucket) => bucket.bucketName == bucketName)
                  ..add(bucketConfig);
              }),
            );
          case null:
            return b.storage = StorageConfig.s3(
              buckets: [bucketConfig],
            );
          case final nonS3Config:
            throw ArgumentError(
              'A non-S3 storage configuration is already present: $nonS3Config',
            );
        }
      });

  /// Adds an S3 storage bucket with name [bucketName] or updates the existing one.
  @useResult
  AWSAmplifyConfig updateStorageBucket(
    String bucketName,
    void Function(StorageS3BucketBuilder bucket) builder,
  ) =>
      rebuild((b) {
        switch (b.storage) {
          case StorageConfigS3$(:final s3):
            return b.storage = StorageConfigS3$(
              s3.rebuild((s3) {
                final existingBucket = s3.buckets.build().firstWhereOrNull(
                      (bucket) => bucket.bucketName == bucketName,
                    );
                final newBucket = existingBucket?.rebuild(builder) ??
                    StorageS3Bucket.build(builder);
                s3.buckets
                  ..remove(existingBucket)
                  ..add(newBucket);
              }),
            );
          case null:
            return b.storage = StorageConfig.s3(
              buckets: [StorageS3Bucket.build(builder)],
            );
          case final nonS3Config:
            throw ArgumentError(
              'A non-S3 storage configuration is already present: $nonS3Config',
            );
        }
      });

  /// Converts this to a CLI-compatible representation.
  @useResult
  core.AmplifyConfig toCli() {
    core.AnalyticsConfig? analytics;
    if (this.analytics?.pinpoint
        case AnalyticsPinpointConfig(
          :final appId,
          :final region,
          :final autoFlushEventsInterval
        )) {
      analytics = core.AnalyticsConfig(
        plugins: {
          core.PinpointPluginConfig.pluginKey: core.PinpointPluginConfig(
            pinpointAnalytics:
                core.PinpointAnalytics(appId: appId, region: region),
            pinpointTargeting: core.PinpointTargeting(region: region),
            autoFlushEventsInterval: autoFlushEventsInterval,
          ),
        },
      );
    }

    core.ApiConfig? api;
    if (this.api?.endpoints case final apis?) {
      final endpoints = <String, core.AWSApiConfig>{};
      void addEndpoint(ApiEndpointConfig endpointConfig) {
        final (name, endpoint) = switch (endpointConfig) {
          ApiEndpointConfigAppSync$(:final appSync) => (
              appSync.name,
              core.AWSApiConfig(
                endpointType: core.EndpointType.graphQL,
                endpoint: appSync.endpoint.toString(),
                region: appSync.region,
                authorizationType: appSync.authMode.authorizationType,
                apiKey: switch (appSync.authMode) {
                  ApiAuthorizationModeApiKey$(:final apiKey) => apiKey,
                  _ => null,
                },
              ),
            ),
          ApiEndpointConfigApiGateway$(:final apiGateway) => (
              apiGateway.name,
              core.AWSApiConfig(
                endpointType: core.EndpointType.rest,
                endpoint: apiGateway.endpoint.toString(),
                region: apiGateway.region,
                authorizationType: apiGateway.authMode.authorizationType,
                apiKey: switch (apiGateway.authMode) {
                  ApiAuthorizationModeApiKey$(:final apiKey) => apiKey,
                  _ => null,
                },
              ),
            ),
          ApiEndpointConfigRest$(:final rest) => (
              rest.name,
              core.AWSApiConfig(
                endpointType: core.EndpointType.rest,
                endpoint: rest.endpoint.toString(),
                authorizationType: core.APIAuthorizationType.none,
              ),
            ),
          _ => throw ArgumentError(
              'Unsupported CLI endpoint type: $endpointConfig',
            ),
        };
        endpoints[name] = endpoint;
      }

      for (final endpointConfig in apis) {
        addEndpoint(endpointConfig);
      }
      api = core.ApiConfig(
        plugins: {
          core.AWSApiPluginConfig.pluginKey: core.AWSApiPluginConfig(endpoints),
        },
      );
    }

    core.AuthConfig? auth;
    if (this.auth?.cognito
        case AuthCognitoConfig(:final userPool, :final identityPool)) {
      final oAuthConfig = userPool?.hostedUi?.let(
        (hostedUi) => core.CognitoOAuthConfig(
          appClientId: hostedUi.clientId ?? userPool.clientId,
          appClientSecret: hostedUi.clientSecret ?? userPool.clientSecret,
          webDomain: hostedUi.domainName,
          scopes: hostedUi.scopes.toList(),
          signInRedirectUri: hostedUi.signInRedirectUris.join(','),
          signOutRedirectUri: hostedUi.signOutRedirectUris.join(','),
          signInUri:
              hostedUi.signInUri?.replace(queryParameters: {}).toString(),
          signOutUri:
              hostedUi.signOutUri?.replace(queryParameters: {}).toString(),
          signInUriQueryParameters: hostedUi.signInUri?.queryParameters,
          signOutUriQueryParameters: hostedUi.signOutUri?.queryParameters,
          tokenUri: hostedUi.tokenUri?.replace(queryParameters: {}).toString(),
          tokenUriQueryParameters: hostedUi.tokenUri?.queryParameters,
        ),
      );
      auth = core.AuthConfig(
        plugins: {
          core.CognitoPluginConfig.pluginKey: core.CognitoPluginConfig(
            auth: core.AWSConfigMap.withDefault(
              core.CognitoAuthConfig(
                oAuth: oAuthConfig,
                authenticationFlowType: userPool?.authFlowType?.let(
                  (flow) => AuthenticationFlowType.values
                      .firstWhere((v) => v.value == flow.value),
                ),
                socialProviders: userPool?.socialProviders
                    ?.map(
                      (p) => switch (p) {
                        AuthProvider.amazon => core.SocialProvider.amazon,
                        AuthProvider.apple => core.SocialProvider.apple,
                        AuthProvider.facebook => core.SocialProvider.facebook,
                        AuthProvider.google => core.SocialProvider.google,
                        _ => throw ArgumentError.value(
                            p,
                            'socialProvider',
                            'Unsupported provider in the CLI config',
                          ),
                      },
                    )
                    .toList(),
                usernameAttributes: userPool?.usernameAttributes
                    ?.toList()
                    .map(
                      (attr) => CognitoUserAttributeKey.parse(attr.value),
                    )
                    .toList(),
                signupAttributes: userPool?.signUpAttributes?.toList(),
                passwordProtectionSettings: userPool?.passwordPolicy?.let(
                  (passwordPolicy) => core.PasswordProtectionSettings(
                    passwordPolicyMinLength: passwordPolicy.minLength,
                    passwordPolicyCharacters: [
                      if (passwordPolicy.requiresLowercase)
                        core.PasswordPolicyCharacters.requiresLowercase,
                      if (passwordPolicy.requiresUppercase)
                        core.PasswordPolicyCharacters.requiresUppercase,
                      if (passwordPolicy.requiresNumbers)
                        core.PasswordPolicyCharacters.requiresNumbers,
                      if (passwordPolicy.requiresSymbols)
                        core.PasswordPolicyCharacters.requiresSymbols,
                    ],
                  ),
                ),
                mfaConfiguration: userPool?.mfaConfiguration?.enforcementLevel,
                mfaTypes: switch ((
                  userPool?.mfaConfiguration?.sms,
                  userPool?.mfaConfiguration?.totp
                )) {
                  (null, null) => null,
                  (final sms, final totp) => [
                      if (sms ?? false) MfaType.sms,
                      if (totp ?? false) MfaType.totp,
                    ],
                },
                verificationMechanisms:
                    userPool?.verificationMechanisms?.toList(),
              ),
            ),
            cognitoUserPool: userPool?.let(
              (userPoolConfig) => core.AWSConfigMap.withDefault(
                core.CognitoUserPoolConfig(
                  appClientId: userPoolConfig.clientId,
                  appClientSecret: userPoolConfig.clientSecret,
                  poolId: userPoolConfig.poolId,
                  region: userPoolConfig.region,
                  endpoint: userPoolConfig.endpoint?.toString(),
                  hostedUI: oAuthConfig,
                ),
              ),
            ),
            credentialsProvider: identityPool?.let(
              (identityPoolConfig) => core.CredentialsProviders(
                core.AWSConfigMap({
                  core.CognitoIdentityCredentialsProvider.configKey:
                      core.AWSConfigMap.withDefault(
                    core.CognitoIdentityCredentialsProvider(
                      poolId: identityPoolConfig.poolId,
                      region: identityPool.region,
                    ),
                  ),
                }),
              ),
            ),
            pinpointAnalytics: userPool?.pinpointConfig?.let(
              (pinpointConfig) => core.AWSConfigMap.withDefault(
                core.CognitoPinpointAnalyticsConfig(
                  appId: pinpointConfig.appId,
                  region: pinpointConfig.region,
                ),
              ),
            ),
            pinpointTargeting: userPool?.pinpointConfig?.let(
              (pinpointConfig) => core.AWSConfigMap.withDefault(
                core.CognitoPinpointTargetingConfig(
                  region: pinpointConfig.region,
                ),
              ),
            ),
          ),
        },
      );
    }

    core.LoggingConfig? logging;
    if (this.logging?.cloudWatch case final loggingConfig?) {
      logging = core.LoggingConfig(
        plugins: {
          core.CloudWatchPluginConfig.pluginKey: core.CloudWatchPluginConfig(
            enable: loggingConfig.enable,
            logGroupName: loggingConfig.logGroupName,
            region: loggingConfig.region,
            flushIntervalInSeconds: loggingConfig.flushInterval,
            localStoreMaxSizeInMB: loggingConfig.localStoreMaxSize,
            defaultRemoteConfiguration:
                loggingConfig.defaultRemoteConfiguration?.let(
              (remoteConfig) => core.DefaultRemoteConfiguration(
                endpoint: remoteConfig.endpoint.toString(),
                refreshIntervalInSeconds: remoteConfig.refreshInterval,
              ),
            ),
            loggingConstraints: loggingConfig.loggingConstraints?.let(
              (constraints) => core.LoggingConstraints(
                defaultLogLevel: constraints.defaultLogLevel,
                categoryLogLevel: constraints.categoryLogLevel.toMap(),
                userLogLevel: constraints.userLogLevel.toMap(),
              ),
            ),
          ),
        },
      );
    }

    core.NotificationsConfig? notifications;
    if (this.notifications?.push?.pinpoint
        case PushNotificationsPinpointConfig(:final appId, :final region)) {
      notifications = core.NotificationsConfig(
        plugins: {
          core.NotificationsPinpointPluginConfig.pluginKey:
              core.NotificationsPinpointPluginConfig(
            appId: appId,
            region: region,
          ),
        },
      );
    }

    core.StorageConfig? storage;
    if (this.storage?.s3?.buckets case final buckets?) {
      final StorageS3Bucket(:bucketName, :region, :defaultAccessLevel) =
          buckets.first;
      if (buckets.length > 1) {
        logger.warn(
          'The CLI config does not currently support multiple buckets. '
          'Including "$bucketName".',
        );
      }
      storage = core.StorageConfig(
        plugins: {
          core.S3PluginConfig.pluginKey: core.S3PluginConfig(
            bucket: bucketName,
            region: region,
            defaultAccessLevel: defaultAccessLevel,
          ),
        },
      );
    }

    return core.AmplifyConfig(
      analytics: analytics,
      api: api,
      auth: auth,
      logging: logging,
      notifications: notifications,
      storage: storage,
    );
  }

  @override
  Map<String, Object?> toJson() {
    final serializersBuilder = Serializers().toBuilder()
      ..add(serializer)
      ..addAll(serializers)
      ..addAll(const [
        UnitSerializer(),

        // We need a built_value serializer for each overridden type
        _StandardEnumSerializer<LogLevel>('LogLevel', LogLevel.values),
        _StandardEnumSerializer<core.Category>(
          'Category',
          core.Category.values,
        ),
        _StandardEnumSerializer<AuthenticationFlowType>(
          'AuthenticationFlowType',
          AuthenticationFlowType.values,
        ),
        _StandardEnumSerializer<core.MfaType>('MfaType', core.MfaType.values),
        _StandardEnumSerializer<core.MfaConfiguration>(
          'MfaConfiguration',
          core.MfaConfiguration.values,
        ),
        _StandardEnumSerializer<core.PasswordPolicyCharacters>(
          'PasswordPolicyCharacters',
          core.PasswordPolicyCharacters.values,
        ),
        _StandardEnumSerializer<StorageAccessLevel>(
          'StorageAccessLevel',
          StorageAccessLevel.values,
        ),
        _CognitoUserAttributeKeySerializer(),
        _AuthProviderSerializer(),
      ])
      ..addPlugin(StandardJsonPlugin());

    for (final MapEntry(key: type, value: factory)
        in builderFactories.entries) {
      serializersBuilder.addBuilderFactory(type, factory);
    }

    return serializersBuilder.build().serializeWith(serializer, this)
        as Map<String, Object?>;
  }

  @override
  List<Object?> get props => [
        analytics,
        api,
        auth,
        logging,
        notifications,
        storage,
      ];

  @override
  String get runtimeTypeName => 'AWSAmplifyConfig';
}

extension<T extends Object> on T {
  R? let<R>(R Function(T) fn) => fn(this);
}

/// Helpers for working with [ApiEndpointConfig].
extension ApiEndpointConfigHelpers on ApiEndpointConfig {
  /// The endpoint type of this.
  core.EndpointType get endpointType => switch (this) {
        ApiEndpointConfigAppSync$ _ => core.EndpointType.graphQL,
        ApiEndpointConfigApiGateway$ _ ||
        ApiEndpointConfigRest$ _ =>
          core.EndpointType.rest,
        _ => throw ArgumentError('Invalid API: $this'),
      };

  /// The default API authorization mode.
  ApiAuthorizationMode get defaultAuthorizationMode => switch (this) {
        ApiEndpointConfigRest$ _ => const ApiAuthorizationMode.none(),
        ApiEndpointConfigApiGateway$(
          apiGateway: ApiGatewayEndpointConfig(:final authMode)
        ) =>
          authMode,
        ApiEndpointConfigAppSync$(
          appSync: AppSyncEndpointConfig(:final authMode)
        ) =>
          authMode,
        _ => throw ArgumentError('Invalid endpoint config: $this'),
      };

  /// The default API authorization type.
  core.APIAuthorizationType get defaultAuthorizationType =>
      defaultAuthorizationMode.authorizationType;

  /// All the auth modes for the API.
  Iterable<ApiAuthorizationMode> get allAuthModes sync* {
    yield defaultAuthorizationMode;
    if (appSync case AppSyncEndpointConfig(:final additionalAuthModes)) {
      yield* additionalAuthModes;
    }
  }

  /// The API key for the endpoint.
  String? get apiKey {
    for (final authMode in allAuthModes) {
      if (authMode case ApiAuthorizationModeApiKey$(:final apiKey)) {
        return apiKey;
      }
    }
    return null;
  }

  /// The endpoint of the API.
  Uri get endpoint => switch (this) {
        ApiEndpointConfigAppSync$(
          appSync: AppSyncEndpointConfig(:final endpoint)
        ) =>
          endpoint,
        ApiEndpointConfigApiGateway$(
          apiGateway: ApiGatewayEndpointConfig(:final endpoint)
        ) =>
          endpoint,
        ApiEndpointConfigRest$(rest: RestEndpointConfig(:final endpoint)) =>
          endpoint,
        _ => throw ArgumentError('Invalid endpoint config: $this'),
      };

  /// The AWS region of the [endpoint].
  String? get awsRegion => switch (this) {
        ApiEndpointConfigApiGateway$(
          apiGateway: ApiGatewayEndpointConfig(:final region)
        ) =>
          region,
        ApiEndpointConfigAppSync$(
          appSync: AppSyncEndpointConfig(:final region)
        ) =>
          region,
        _ => null,
      };
}

extension on core.AWSApiConfig {
  ApiAuthorizationMode get defaultAuthMode => switch (authorizationType) {
        core.APIAuthorizationType.apiKey =>
          ApiAuthorizationMode.apiKey(apiKey!),
        core.APIAuthorizationType.iam => const ApiAuthorizationMode.iam(),
        core.APIAuthorizationType.userPools =>
          const ApiAuthorizationMode.userPools(),
        core.APIAuthorizationType.oidc => const ApiAuthorizationMode.oidc(),
        core.APIAuthorizationType.function =>
          const ApiAuthorizationMode.function(),
        core.APIAuthorizationType.none => const ApiAuthorizationMode.none(),
      };
}

/// Helpers for working with [ApiAuthorizationMode].
extension AWSApiAuthorizationModeHelpers on ApiAuthorizationMode {
  /// The CLI [core.APIAuthorizationType] of this.
  core.APIAuthorizationType get authorizationType => switch (this) {
        ApiAuthorizationModeApiKey$ _ => core.APIAuthorizationType.apiKey,
        ApiAuthorizationModeIam$ _ => core.APIAuthorizationType.iam,
        ApiAuthorizationModeUserPools$ _ => core.APIAuthorizationType.userPools,
        ApiAuthorizationModeOidc$ _ => core.APIAuthorizationType.oidc,
        ApiAuthorizationModeFunction$ _ => core.APIAuthorizationType.function,
        ApiAuthorizationModeNone$ _ => core.APIAuthorizationType.none,
        _ => throw ArgumentError('Invalid authorization mode: $this'),
      };
}

// ignore_for_file: non_constant_identifier_names, constant_identifier_names
final class LocalStorageSize {
  const LocalStorageSize._(this._bytes);

  const LocalStorageSize.kB(int kilobytes) : this._(kilobytes * _kB);
  const LocalStorageSize.MB(int megabytes) : this._(megabytes * _MB);
  const LocalStorageSize.GB(int gigabytes) : this._(gigabytes * _GB);

  const LocalStorageSize.KiB(int kilobytes) : this._(kilobytes * _KiB);
  const LocalStorageSize.MiB(int megabytes) : this._(megabytes * _MiB);
  const LocalStorageSize.GiB(int gigabytes) : this._(gigabytes * _GiB);

  static const int _kB = 1000;
  static const int _MB = 1000 * _kB;
  static const int _GB = 1000 * _MB;

  static const int _KiB = 1024;
  static const int _MiB = 1024 * _KiB;
  static const int _GiB = 1024 * _MiB;

  final int _bytes;

  int get inKilobytes => _bytes ~/ _kB;
  int get inMegabytes => _bytes ~/ _MB;
  int get inGigabytes => _bytes ~/ _MB;

  int get inKibibytes => _bytes ~/ _KiB;
  int get inMebibytes => _bytes ~/ _MiB;
  int get inGibibytes => _bytes ~/ _GiB;
}

final class _StandardEnumSerializer<T extends Enum>
    implements PrimitiveSerializer<T> {
  const _StandardEnumSerializer(this.wireName, this.values);

  @override
  final String wireName;
  final List<T> values;

  static Never _invalidEnumValue(Object value) =>
      throw ArgumentError('Invalid enum value: $value');

  @override
  T deserialize(
    Serializers serializers,
    Object serialized, {
    FullType specifiedType = FullType.unspecified,
  }) {
    return values.firstWhere(
      (val) => val.name.screamingCase == serialized,
      orElse: () => _invalidEnumValue(serialized),
    );
  }

  @override
  Object serialize(
    Serializers serializers,
    T object, {
    FullType specifiedType = FullType.unspecified,
  }) {
    return object.name.screamingCase;
  }

  @override
  Iterable<Type> get types => [T];
}

final class _CognitoUserAttributeKeySerializer
    implements PrimitiveSerializer<CognitoUserAttributeKey> {
  const _CognitoUserAttributeKeySerializer();

  @override
  CognitoUserAttributeKey deserialize(
    Serializers serializers,
    Object serialized, {
    FullType specifiedType = FullType.unspecified,
  }) {
    final key = switch (serialized) {
      String _ => serialized,
      _ => throw ArgumentError('Invalid attribute key: $serialized'),
    };
    return CognitoUserAttributeKey.parse(key.toLowerCase());
  }

  @override
  Object serialize(
    Serializers serializers,
    CognitoUserAttributeKey object, {
    FullType specifiedType = FullType.unspecified,
  }) {
    return object.toJson().toUpperCase();
  }

  @override
  Iterable<Type> get types => const [CognitoUserAttributeKey];

  @override
  String get wireName => 'CognitoUserAttributeKey';
}

final class _AuthProviderSerializer
    implements StructuredSerializer<AuthProvider> {
  const _AuthProviderSerializer();

  @override
  AuthProvider deserialize(
    Serializers serializers,
    Iterable<Object?> serialized, {
    FullType specifiedType = FullType.unspecified,
  }) {
    final values = serialized.toList();
    return AuthProvider.fromJson({
      'name': values.first as String,
      'identityPoolProvider': values.length > 1 ? values[1] as String? : null,
    });
  }

  @override
  Iterable<Object?> serialize(
    Serializers serializers,
    AuthProvider object, {
    FullType specifiedType = FullType.unspecified,
  }) {
    return object.toJson().values;
  }

  @override
  Iterable<Type> get types => const [AuthProvider];

  @override
  String get wireName => 'AuthProvider';
}

typedef MfaStatus = core.MfaConfiguration;
