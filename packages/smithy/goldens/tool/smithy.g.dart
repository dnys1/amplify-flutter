// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: overridden_fields
// ignore_for_file: unnecessary_cast
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "dart:isolate" show ReceivePort;
import "dart:ffi" as ffi;
import "package:jni/internal_helpers_for_jnigen.dart";
import "package:jni/jni.dart" as jni;

// Auto-generated initialization code.

final jniEnv = jni.Jni.env;
final jniAccessors = jni.Jni.accessors;

/// from: software.amazon.smithy.model.Model
///
/// A Smithy model that contains shapes, traits, metadata, and various
/// computed information used to interpret the model.
class Model extends jni.JObject {
  @override
  late final jni.JObjType $type = type;

  Model.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _classRef =
      jniAccessors.getClassOf(r"software/amazon/smithy/model/Model");

  /// The type which includes information such as the signature of this class.
  static const type = $ModelType();

  /// from: static public final java.lang.String MODEL_VERSION
  ///
  /// Specifies the highest supported version of the IDL.
  static const MODEL_VERSION = r"""2.0""";

  static final _id_builder = jniAccessors.getStaticMethodIDOf(
      _classRef, r"builder", r"()Lsoftware/amazon/smithy/model/Model$Builder;");

  /// from: static public software.amazon.smithy.model.Model.Builder builder()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Builds an explicitly configured Smithy model.
  ///
  /// Note that the builder does not validate the correctness of the
  /// model. Use the \#assembler() method to build _and_
  /// validate a model.
  ///@return Returns a model builder.
  ///@see \#assembler()
  static Model_Builder builder() {
    return const $Model_BuilderType().fromRef(jniAccessors
        .callStaticMethodWithArgs(
            _classRef, _id_builder, jni.JniCallType.objectType, []).object);
  }

  static final _id_assembler = jniAccessors.getStaticMethodIDOf(_classRef,
      r"assembler", r"()Lsoftware/amazon/smithy/model/loader/ModelAssembler;");

  /// from: static public software.amazon.smithy.model.loader.ModelAssembler assembler()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Assembles and validates a Smithy model from files, nodes, and other
  /// disparate sources.
  ///@return Returns a model assembler.
  static ModelAssembler assembler() {
    return const $ModelAssemblerType().fromRef(jniAccessors
        .callStaticMethodWithArgs(
            _classRef, _id_assembler, jni.JniCallType.objectType, []).object);
  }

  static final _id_assembler1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      r"assembler",
      r"(Ljava/lang/ClassLoader;)Lsoftware/amazon/smithy/model/loader/ModelAssembler;");

  /// from: static public software.amazon.smithy.model.loader.ModelAssembler assembler(java.lang.ClassLoader classLoader)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a ModelAssembler that is configured to discover traits,
  /// validators, and built-in validators using the given
  /// {@code ClassLoader}.
  ///@param classLoader Class loader used to discover services.
  ///@return Returns a model assembler.
  static ModelAssembler assembler1(
    jni.JObject classLoader,
  ) {
    return const $ModelAssemblerType().fromRef(jniAccessors
        .callStaticMethodWithArgs(_classRef, _id_assembler1,
            jni.JniCallType.objectType, [classLoader.reference]).object);
  }

  static final _id_getMetadataProperty = jniAccessors.getMethodIDOf(_classRef,
      r"getMetadataProperty", r"(Ljava/lang/String;)Ljava/util/Optional;");

  /// from: public java.util.Optional<software.amazon.smithy.model.node.Node> getMetadataProperty(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets a metadata property by namespace and name.
  ///@param name Name of the property to retrieve.
  ///@return Returns the optional property.
  jni.JObject getMetadataProperty(
    jni.JString name,
  ) {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_getMetadataProperty,
        jni.JniCallType.objectType,
        [name.reference]).object);
  }

  static final _id_getMetadata = jniAccessors.getMethodIDOf(
      _classRef, r"getMetadata", r"()Ljava/util/Map;");

  /// from: public java.util.Map<java.lang.String,software.amazon.smithy.model.node.Node> getMetadata()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return Gets the unmodifiable metadata of the model across all
  ///  namespaces.
  jni.JObject getMetadata() {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference, _id_getMetadata, jni.JniCallType.objectType, []).object);
  }

  static final _id_getTraitDefinition = jniAccessors.getMethodIDOf(
      _classRef,
      r"getTraitDefinition",
      r"(Lsoftware/amazon/smithy/model/shapes/ToShapeId;)Ljava/util/Optional;");

  /// from: public java.util.Optional<software.amazon.smithy.model.traits.TraitDefinition> getTraitDefinition(software.amazon.smithy.model.shapes.ToShapeId traitId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the trait definition of a specific trait shape ID.
  ///@param traitId ID of the shape to get the trait definition of.
  ///@return Returns the optionally found trait definition.
  jni.JObject getTraitDefinition(
    jni.JObject traitId,
  ) {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_getTraitDefinition,
        jni.JniCallType.objectType,
        [traitId.reference]).object);
  }

  static final _id_getShapesWithTrait = jniAccessors.getMethodIDOf(
      _classRef,
      r"getShapesWithTrait",
      r"(Lsoftware/amazon/smithy/model/shapes/ToShapeId;)Ljava/util/Set;");

  /// from: public java.util.Set<software.amazon.smithy.model.shapes.Shape> getShapesWithTrait(software.amazon.smithy.model.shapes.ToShapeId trait)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets a set of shapes in the model marked with a specific trait.
  ///@param trait Trait shape ID to look for on shapes.
  ///@return Returns the immutable set of matching shapes.
  jni.JObject getShapesWithTrait(
    jni.JObject trait,
  ) {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_getShapesWithTrait,
        jni.JniCallType.objectType,
        [trait.reference]).object);
  }

  static final _id_getShapeIds = jniAccessors.getMethodIDOf(
      _classRef, r"getShapeIds", r"()Ljava/util/Set;");

  /// from: public java.util.Set<software.amazon.smithy.model.shapes.ShapeId> getShapeIds()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the immutable set of {@code ShapeId} in the model.
  ///@return Returns the shape IDs.
  jni.JObject getShapeIds() {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference, _id_getShapeIds, jni.JniCallType.objectType, []).object);
  }

  static final _id_getShapesWithTrait1 = jniAccessors.getMethodIDOf(
      _classRef, r"getShapesWithTrait", r"(Ljava/lang/Class;)Ljava/util/Set;");

  /// from: public java.util.Set<software.amazon.smithy.model.shapes.Shape> getShapesWithTrait(java.lang.Class<? extends software.amazon.smithy.model.traits.Trait> trait)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets a set of shapes in the model marked with a specific trait.
  ///
  /// The result is an exact match on trait classes and does not utilize
  /// any kind of polymorphic instance of checks.
  ///@param trait Trait class to look for on shapes.
  ///@return Returns the immutable set of matching shapes.
  jni.JObject getShapesWithTrait1(
    jni.JObject trait,
  ) {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_getShapesWithTrait1,
        jni.JniCallType.objectType,
        [trait.reference]).object);
  }

  static final _id_getBigDecimalShapes = jniAccessors.getMethodIDOf(
      _classRef, r"getBigDecimalShapes", r"()Ljava/util/Set;");

  /// from: public java.util.Set<software.amazon.smithy.model.shapes.BigDecimalShape> getBigDecimalShapes()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets an immutable set of all bigDecimals in the Model.
  ///@return Returns the Set of {@code bigDecimals}s.
  jni.JObject getBigDecimalShapes() {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_getBigDecimalShapes,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_getBigDecimalShapesWithTrait = jniAccessors.getMethodIDOf(
      _classRef,
      r"getBigDecimalShapesWithTrait",
      r"(Ljava/lang/Class;)Ljava/util/Set;");

  /// from: public java.util.Set<software.amazon.smithy.model.shapes.BigDecimalShape> getBigDecimalShapesWithTrait(java.lang.Class<? extends software.amazon.smithy.model.traits.Trait> trait)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets an immutable set of all bigDecimals in the Model that have a specific trait.
  ///@param trait The exact trait class to look for on shapes.
  ///@return Returns the set of {@code bigdecimal}s that have a specific trait.
  jni.JObject getBigDecimalShapesWithTrait(
    jni.JObject trait,
  ) {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_getBigDecimalShapesWithTrait,
        jni.JniCallType.objectType,
        [trait.reference]).object);
  }

  static final _id_getBigIntegerShapes = jniAccessors.getMethodIDOf(
      _classRef, r"getBigIntegerShapes", r"()Ljava/util/Set;");

  /// from: public java.util.Set<software.amazon.smithy.model.shapes.BigIntegerShape> getBigIntegerShapes()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets an immutable set of all bigIntegers in the Model.
  ///@return Returns the Set of {@code bigIntegers}s.
  jni.JObject getBigIntegerShapes() {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_getBigIntegerShapes,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_getBigIntegerShapesWithTrait = jniAccessors.getMethodIDOf(
      _classRef,
      r"getBigIntegerShapesWithTrait",
      r"(Ljava/lang/Class;)Ljava/util/Set;");

  /// from: public java.util.Set<software.amazon.smithy.model.shapes.BigIntegerShape> getBigIntegerShapesWithTrait(java.lang.Class<? extends software.amazon.smithy.model.traits.Trait> trait)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets an immutable set of all bigIntegers in the Model that have a specific trait.
  ///@param trait The exact trait class to look for on shapes.
  ///@return Returns the set of {@code bigIntegers}s that have a specific trait.
  jni.JObject getBigIntegerShapesWithTrait(
    jni.JObject trait,
  ) {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_getBigIntegerShapesWithTrait,
        jni.JniCallType.objectType,
        [trait.reference]).object);
  }

  static final _id_getBlobShapes = jniAccessors.getMethodIDOf(
      _classRef, r"getBlobShapes", r"()Ljava/util/Set;");

  /// from: public java.util.Set<software.amazon.smithy.model.shapes.BlobShape> getBlobShapes()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets an immutable set of all blobs in the Model.
  ///@return Returns the Set of {@code blob}s.
  jni.JObject getBlobShapes() {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference, _id_getBlobShapes, jni.JniCallType.objectType, []).object);
  }

  static final _id_getBlobShapesWithTrait = jniAccessors.getMethodIDOf(
      _classRef,
      r"getBlobShapesWithTrait",
      r"(Ljava/lang/Class;)Ljava/util/Set;");

  /// from: public java.util.Set<software.amazon.smithy.model.shapes.BlobShape> getBlobShapesWithTrait(java.lang.Class<? extends software.amazon.smithy.model.traits.Trait> trait)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets an immutable set of all blobs in the Model that have a specific trait.
  ///@param trait The exact trait class to look for on shapes.
  ///@return Returns the set of {@code blob}s that have a specific trait.
  jni.JObject getBlobShapesWithTrait(
    jni.JObject trait,
  ) {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_getBlobShapesWithTrait,
        jni.JniCallType.objectType,
        [trait.reference]).object);
  }

  static final _id_getBooleanShapes = jniAccessors.getMethodIDOf(
      _classRef, r"getBooleanShapes", r"()Ljava/util/Set;");

  /// from: public java.util.Set<software.amazon.smithy.model.shapes.BooleanShape> getBooleanShapes()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets an immutable set of all booleans in the Model.
  ///@return Returns the Set of {@code boolean}s.
  jni.JObject getBooleanShapes() {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_getBooleanShapes,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_getBooleanShapesWithTrait = jniAccessors.getMethodIDOf(
      _classRef,
      r"getBooleanShapesWithTrait",
      r"(Ljava/lang/Class;)Ljava/util/Set;");

  /// from: public java.util.Set<software.amazon.smithy.model.shapes.BooleanShape> getBooleanShapesWithTrait(java.lang.Class<? extends software.amazon.smithy.model.traits.Trait> trait)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets an immutable set of all booleans in the Model that have a specific trait.
  ///@param trait The exact trait class to look for on shapes.
  ///@return Returns the set of {@code boolean}s that have a specific trait.
  jni.JObject getBooleanShapesWithTrait(
    jni.JObject trait,
  ) {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_getBooleanShapesWithTrait,
        jni.JniCallType.objectType,
        [trait.reference]).object);
  }

  static final _id_getByteShapes = jniAccessors.getMethodIDOf(
      _classRef, r"getByteShapes", r"()Ljava/util/Set;");

  /// from: public java.util.Set<software.amazon.smithy.model.shapes.ByteShape> getByteShapes()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets an immutable set of all bytes in the Model.
  ///@return Returns the Set of {@code byte}s.
  jni.JObject getByteShapes() {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference, _id_getByteShapes, jni.JniCallType.objectType, []).object);
  }

  static final _id_getByteShapesWithTrait = jniAccessors.getMethodIDOf(
      _classRef,
      r"getByteShapesWithTrait",
      r"(Ljava/lang/Class;)Ljava/util/Set;");

  /// from: public java.util.Set<software.amazon.smithy.model.shapes.ByteShape> getByteShapesWithTrait(java.lang.Class<? extends software.amazon.smithy.model.traits.Trait> trait)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets an immutable set of all bytes in the Model that have a specific trait.
  ///@param trait The exact trait class to look for on shapes.
  ///@return Returns the set of {@code byte}s that have a specific trait.
  jni.JObject getByteShapesWithTrait(
    jni.JObject trait,
  ) {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_getByteShapesWithTrait,
        jni.JniCallType.objectType,
        [trait.reference]).object);
  }

  static final _id_getDocumentShapes = jniAccessors.getMethodIDOf(
      _classRef, r"getDocumentShapes", r"()Ljava/util/Set;");

  /// from: public java.util.Set<software.amazon.smithy.model.shapes.DocumentShape> getDocumentShapes()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets an immutable set of all documents in the Model.
  ///@return Returns the Set of {@code document}s.
  jni.JObject getDocumentShapes() {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_getDocumentShapes,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_getDocumentShapesWithTrait = jniAccessors.getMethodIDOf(
      _classRef,
      r"getDocumentShapesWithTrait",
      r"(Ljava/lang/Class;)Ljava/util/Set;");

  /// from: public java.util.Set<software.amazon.smithy.model.shapes.DocumentShape> getDocumentShapesWithTrait(java.lang.Class<? extends software.amazon.smithy.model.traits.Trait> trait)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets an immutable set of all documents in the Model that have a specific trait.
  ///@param trait The exact trait class to look for on shapes.
  ///@return Returns the set of {@code document}s that have a specific trait.
  jni.JObject getDocumentShapesWithTrait(
    jni.JObject trait,
  ) {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_getDocumentShapesWithTrait,
        jni.JniCallType.objectType,
        [trait.reference]).object);
  }

  static final _id_getDoubleShapes = jniAccessors.getMethodIDOf(
      _classRef, r"getDoubleShapes", r"()Ljava/util/Set;");

  /// from: public java.util.Set<software.amazon.smithy.model.shapes.DoubleShape> getDoubleShapes()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets an immutable set of all doubles in the Model.
  ///@return Returns the Set of {@code double}s.
  jni.JObject getDoubleShapes() {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference, _id_getDoubleShapes, jni.JniCallType.objectType, []).object);
  }

  static final _id_getDoubleShapesWithTrait = jniAccessors.getMethodIDOf(
      _classRef,
      r"getDoubleShapesWithTrait",
      r"(Ljava/lang/Class;)Ljava/util/Set;");

  /// from: public java.util.Set<software.amazon.smithy.model.shapes.DoubleShape> getDoubleShapesWithTrait(java.lang.Class<? extends software.amazon.smithy.model.traits.Trait> trait)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets an immutable set of all doubles in the Model that have a specific trait.
  ///@param trait The exact trait class to look for on shapes.
  ///@return Returns the set of {@code double}s that have a specific trait.
  jni.JObject getDoubleShapesWithTrait(
    jni.JObject trait,
  ) {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_getDoubleShapesWithTrait,
        jni.JniCallType.objectType,
        [trait.reference]).object);
  }

  static final _id_getFloatShapes = jniAccessors.getMethodIDOf(
      _classRef, r"getFloatShapes", r"()Ljava/util/Set;");

  /// from: public java.util.Set<software.amazon.smithy.model.shapes.FloatShape> getFloatShapes()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets an immutable set of all floats in the Model.
  ///@return Returns the Set of {@code float}s.
  jni.JObject getFloatShapes() {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference, _id_getFloatShapes, jni.JniCallType.objectType, []).object);
  }

  static final _id_getFloatShapesWithTrait = jniAccessors.getMethodIDOf(
      _classRef,
      r"getFloatShapesWithTrait",
      r"(Ljava/lang/Class;)Ljava/util/Set;");

  /// from: public java.util.Set<software.amazon.smithy.model.shapes.FloatShape> getFloatShapesWithTrait(java.lang.Class<? extends software.amazon.smithy.model.traits.Trait> trait)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets an immutable set of all floats in the Model that have a specific trait.
  ///@param trait The exact trait class to look for on shapes.
  ///@return Returns the set of {@code float}s that have a specific trait.
  jni.JObject getFloatShapesWithTrait(
    jni.JObject trait,
  ) {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_getFloatShapesWithTrait,
        jni.JniCallType.objectType,
        [trait.reference]).object);
  }

  static final _id_getIntegerShapes = jniAccessors.getMethodIDOf(
      _classRef, r"getIntegerShapes", r"()Ljava/util/Set;");

  /// from: public java.util.Set<software.amazon.smithy.model.shapes.IntegerShape> getIntegerShapes()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets an immutable set of all integers in the Model.
  ///@return Returns the Set of {@code integer}s.
  jni.JObject getIntegerShapes() {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_getIntegerShapes,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_getIntegerShapesWithTrait = jniAccessors.getMethodIDOf(
      _classRef,
      r"getIntegerShapesWithTrait",
      r"(Ljava/lang/Class;)Ljava/util/Set;");

  /// from: public java.util.Set<software.amazon.smithy.model.shapes.IntegerShape> getIntegerShapesWithTrait(java.lang.Class<? extends software.amazon.smithy.model.traits.Trait> trait)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets an immutable set of all integers in the Model that have a specific trait.
  ///@param trait The exact trait class to look for on shapes.
  ///@return Returns the set of {@code integer}s that have a specific trait.
  jni.JObject getIntegerShapesWithTrait(
    jni.JObject trait,
  ) {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_getIntegerShapesWithTrait,
        jni.JniCallType.objectType,
        [trait.reference]).object);
  }

  static final _id_getIntEnumShapes = jniAccessors.getMethodIDOf(
      _classRef, r"getIntEnumShapes", r"()Ljava/util/Set;");

  /// from: public java.util.Set<software.amazon.smithy.model.shapes.IntEnumShape> getIntEnumShapes()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets an immutable set of all intEnums in the Model.
  ///@return Returns the Set of {@code intEnum}s.
  jni.JObject getIntEnumShapes() {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_getIntEnumShapes,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_getIntEnumShapesWithTrait = jniAccessors.getMethodIDOf(
      _classRef,
      r"getIntEnumShapesWithTrait",
      r"(Ljava/lang/Class;)Ljava/util/Set;");

  /// from: public java.util.Set<software.amazon.smithy.model.shapes.IntEnumShape> getIntEnumShapesWithTrait(java.lang.Class<? extends software.amazon.smithy.model.traits.Trait> trait)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets an immutable set of all intEnums in the Model that have a specific trait.
  ///@param trait The exact trait class to look for on shapes.
  ///@return Returns the set of {@code intEnum}s that have a specific trait.
  jni.JObject getIntEnumShapesWithTrait(
    jni.JObject trait,
  ) {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_getIntEnumShapesWithTrait,
        jni.JniCallType.objectType,
        [trait.reference]).object);
  }

  static final _id_getListShapes = jniAccessors.getMethodIDOf(
      _classRef, r"getListShapes", r"()Ljava/util/Set;");

  /// from: public java.util.Set<software.amazon.smithy.model.shapes.ListShape> getListShapes()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets an immutable set of all lists in the Model.
  ///@return Returns the Set of {@code list}s.
  jni.JObject getListShapes() {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference, _id_getListShapes, jni.JniCallType.objectType, []).object);
  }

  static final _id_getListShapesWithTrait = jniAccessors.getMethodIDOf(
      _classRef,
      r"getListShapesWithTrait",
      r"(Ljava/lang/Class;)Ljava/util/Set;");

  /// from: public java.util.Set<software.amazon.smithy.model.shapes.ListShape> getListShapesWithTrait(java.lang.Class<? extends software.amazon.smithy.model.traits.Trait> trait)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets an immutable set of all lists in the Model that have a specific trait.
  ///@param trait The exact trait class to look for on shapes.
  ///@return Returns the set of {@code list}s that have a specific trait.
  jni.JObject getListShapesWithTrait(
    jni.JObject trait,
  ) {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_getListShapesWithTrait,
        jni.JniCallType.objectType,
        [trait.reference]).object);
  }

  static final _id_getLongShapes = jniAccessors.getMethodIDOf(
      _classRef, r"getLongShapes", r"()Ljava/util/Set;");

  /// from: public java.util.Set<software.amazon.smithy.model.shapes.LongShape> getLongShapes()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets an immutable set of all longs in the Model.
  ///@return Returns the Set of {@code long}s.
  jni.JObject getLongShapes() {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference, _id_getLongShapes, jni.JniCallType.objectType, []).object);
  }

  static final _id_getLongShapesWithTrait = jniAccessors.getMethodIDOf(
      _classRef,
      r"getLongShapesWithTrait",
      r"(Ljava/lang/Class;)Ljava/util/Set;");

  /// from: public java.util.Set<software.amazon.smithy.model.shapes.LongShape> getLongShapesWithTrait(java.lang.Class<? extends software.amazon.smithy.model.traits.Trait> trait)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets an immutable set of all longs in the Model that have a specific trait.
  ///@param trait The exact trait class to look for on shapes.
  ///@return Returns the set of {@code long}s that have a specific trait.
  jni.JObject getLongShapesWithTrait(
    jni.JObject trait,
  ) {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_getLongShapesWithTrait,
        jni.JniCallType.objectType,
        [trait.reference]).object);
  }

  static final _id_getMapShapes = jniAccessors.getMethodIDOf(
      _classRef, r"getMapShapes", r"()Ljava/util/Set;");

  /// from: public java.util.Set<software.amazon.smithy.model.shapes.MapShape> getMapShapes()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets an immutable set of all maps in the Model.
  ///@return Returns the Set of {@code map}s.
  jni.JObject getMapShapes() {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference, _id_getMapShapes, jni.JniCallType.objectType, []).object);
  }

  static final _id_getMapShapesWithTrait = jniAccessors.getMethodIDOf(_classRef,
      r"getMapShapesWithTrait", r"(Ljava/lang/Class;)Ljava/util/Set;");

  /// from: public java.util.Set<software.amazon.smithy.model.shapes.MapShape> getMapShapesWithTrait(java.lang.Class<? extends software.amazon.smithy.model.traits.Trait> trait)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets an immutable set of all maps in the Model that have a specific trait.
  ///@param trait The exact trait class to look for on shapes.
  ///@return Returns the set of {@code map}s that have a specific trait.
  jni.JObject getMapShapesWithTrait(
    jni.JObject trait,
  ) {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_getMapShapesWithTrait,
        jni.JniCallType.objectType,
        [trait.reference]).object);
  }

  static final _id_getMemberShapes = jniAccessors.getMethodIDOf(
      _classRef, r"getMemberShapes", r"()Ljava/util/Set;");

  /// from: public java.util.Set<software.amazon.smithy.model.shapes.MemberShape> getMemberShapes()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets an immutable set of all members in the Model.
  ///@return Returns the Set of {@code member}s.
  jni.JObject getMemberShapes() {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference, _id_getMemberShapes, jni.JniCallType.objectType, []).object);
  }

  static final _id_getMemberShapesWithTrait = jniAccessors.getMethodIDOf(
      _classRef,
      r"getMemberShapesWithTrait",
      r"(Ljava/lang/Class;)Ljava/util/Set;");

  /// from: public java.util.Set<software.amazon.smithy.model.shapes.MemberShape> getMemberShapesWithTrait(java.lang.Class<? extends software.amazon.smithy.model.traits.Trait> trait)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets an immutable set of all members in the Model that have a specific trait.
  ///@param trait The exact trait class to look for on shapes.
  ///@return Returns the set of {@code member}s that have a specific trait.
  jni.JObject getMemberShapesWithTrait(
    jni.JObject trait,
  ) {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_getMemberShapesWithTrait,
        jni.JniCallType.objectType,
        [trait.reference]).object);
  }

  static final _id_getOperationShapes = jniAccessors.getMethodIDOf(
      _classRef, r"getOperationShapes", r"()Ljava/util/Set;");

  /// from: public java.util.Set<software.amazon.smithy.model.shapes.OperationShape> getOperationShapes()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets an immutable set of all operations in the Model.
  ///@return Returns the Set of {@code operation}s.
  jni.JObject getOperationShapes() {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_getOperationShapes,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_getOperationShapesWithTrait = jniAccessors.getMethodIDOf(
      _classRef,
      r"getOperationShapesWithTrait",
      r"(Ljava/lang/Class;)Ljava/util/Set;");

  /// from: public java.util.Set<software.amazon.smithy.model.shapes.OperationShape> getOperationShapesWithTrait(java.lang.Class<? extends software.amazon.smithy.model.traits.Trait> trait)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets an immutable set of all operations in the Model that have a specific trait.
  ///@param trait The exact trait class to look for on shapes.
  ///@return Returns the set of {@code operation}s that have a specific trait.
  jni.JObject getOperationShapesWithTrait(
    jni.JObject trait,
  ) {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_getOperationShapesWithTrait,
        jni.JniCallType.objectType,
        [trait.reference]).object);
  }

  static final _id_getResourceShapes = jniAccessors.getMethodIDOf(
      _classRef, r"getResourceShapes", r"()Ljava/util/Set;");

  /// from: public java.util.Set<software.amazon.smithy.model.shapes.ResourceShape> getResourceShapes()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets an immutable set of all resources in the Model.
  ///@return Returns the Set of {@code resource}s.
  jni.JObject getResourceShapes() {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_getResourceShapes,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_getResourceShapesWithTrait = jniAccessors.getMethodIDOf(
      _classRef,
      r"getResourceShapesWithTrait",
      r"(Ljava/lang/Class;)Ljava/util/Set;");

  /// from: public java.util.Set<software.amazon.smithy.model.shapes.ResourceShape> getResourceShapesWithTrait(java.lang.Class<? extends software.amazon.smithy.model.traits.Trait> trait)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets an immutable set of all resources in the Model that have a specific trait.
  ///@param trait The exact trait class to look for on shapes.
  ///@return Returns the set of {@code resource}s that have a specific trait.
  jni.JObject getResourceShapesWithTrait(
    jni.JObject trait,
  ) {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_getResourceShapesWithTrait,
        jni.JniCallType.objectType,
        [trait.reference]).object);
  }

  static final _id_getServiceShapes = jniAccessors.getMethodIDOf(
      _classRef, r"getServiceShapes", r"()Ljava/util/Set;");

  /// from: public java.util.Set<software.amazon.smithy.model.shapes.ServiceShape> getServiceShapes()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets an immutable set of all services in the Model.
  ///@return Returns the Set of {@code service}s.
  jni.JObject getServiceShapes() {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_getServiceShapes,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_getServiceShapesWithTrait = jniAccessors.getMethodIDOf(
      _classRef,
      r"getServiceShapesWithTrait",
      r"(Ljava/lang/Class;)Ljava/util/Set;");

  /// from: public java.util.Set<software.amazon.smithy.model.shapes.ServiceShape> getServiceShapesWithTrait(java.lang.Class<? extends software.amazon.smithy.model.traits.Trait> trait)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets an immutable set of all services in the Model that have a specific trait.
  ///@param trait The exact trait class to look for on shapes.
  ///@return Returns the set of {@code service}s that have a specific trait.
  jni.JObject getServiceShapesWithTrait(
    jni.JObject trait,
  ) {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_getServiceShapesWithTrait,
        jni.JniCallType.objectType,
        [trait.reference]).object);
  }

  static final _id_getSetShapes = jniAccessors.getMethodIDOf(
      _classRef, r"getSetShapes", r"()Ljava/util/Set;");

  /// from: public java.util.Set<software.amazon.smithy.model.shapes.SetShape> getSetShapes()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets an immutable set of all sets in the Model.
  ///@return Returns the Set of {@code set}s.
  jni.JObject getSetShapes() {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference, _id_getSetShapes, jni.JniCallType.objectType, []).object);
  }

  static final _id_getSetShapesWithTrait = jniAccessors.getMethodIDOf(_classRef,
      r"getSetShapesWithTrait", r"(Ljava/lang/Class;)Ljava/util/Set;");

  /// from: public java.util.Set<software.amazon.smithy.model.shapes.SetShape> getSetShapesWithTrait(java.lang.Class<? extends software.amazon.smithy.model.traits.Trait> trait)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets an immutable set of all sets in the Model that have a specific trait.
  ///@param trait The exact trait class to look for on shapes.
  ///@return Returns the set of {@code set}s that have a specific trait.
  jni.JObject getSetShapesWithTrait(
    jni.JObject trait,
  ) {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_getSetShapesWithTrait,
        jni.JniCallType.objectType,
        [trait.reference]).object);
  }

  static final _id_getShortShapes = jniAccessors.getMethodIDOf(
      _classRef, r"getShortShapes", r"()Ljava/util/Set;");

  /// from: public java.util.Set<software.amazon.smithy.model.shapes.ShortShape> getShortShapes()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets an immutable set of all shorts in the Model.
  ///@return Returns the Set of {@code short}s.
  jni.JObject getShortShapes() {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference, _id_getShortShapes, jni.JniCallType.objectType, []).object);
  }

  static final _id_getShortShapesWithTrait = jniAccessors.getMethodIDOf(
      _classRef,
      r"getShortShapesWithTrait",
      r"(Ljava/lang/Class;)Ljava/util/Set;");

  /// from: public java.util.Set<software.amazon.smithy.model.shapes.ShortShape> getShortShapesWithTrait(java.lang.Class<? extends software.amazon.smithy.model.traits.Trait> trait)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets an immutable set of all shorts in the Model that have a specific trait.
  ///@param trait The exact trait class to look for on shapes.
  ///@return Returns the set of {@code short}s that have a specific trait.
  jni.JObject getShortShapesWithTrait(
    jni.JObject trait,
  ) {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_getShortShapesWithTrait,
        jni.JniCallType.objectType,
        [trait.reference]).object);
  }

  static final _id_getStringShapes = jniAccessors.getMethodIDOf(
      _classRef, r"getStringShapes", r"()Ljava/util/Set;");

  /// from: public java.util.Set<software.amazon.smithy.model.shapes.StringShape> getStringShapes()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets an immutable set of all strings in the Model.
  ///@return Returns the Set of {@code string}s.
  jni.JObject getStringShapes() {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference, _id_getStringShapes, jni.JniCallType.objectType, []).object);
  }

  static final _id_getStringShapesWithTrait = jniAccessors.getMethodIDOf(
      _classRef,
      r"getStringShapesWithTrait",
      r"(Ljava/lang/Class;)Ljava/util/Set;");

  /// from: public java.util.Set<software.amazon.smithy.model.shapes.StringShape> getStringShapesWithTrait(java.lang.Class<? extends software.amazon.smithy.model.traits.Trait> trait)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets an immutable set of all strings in the Model that have a specific trait.
  ///@param trait The exact trait class to look for on shapes.
  ///@return Returns the set of {@code string}s that have a specific trait.
  jni.JObject getStringShapesWithTrait(
    jni.JObject trait,
  ) {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_getStringShapesWithTrait,
        jni.JniCallType.objectType,
        [trait.reference]).object);
  }

  static final _id_getEnumShapes = jniAccessors.getMethodIDOf(
      _classRef, r"getEnumShapes", r"()Ljava/util/Set;");

  /// from: public java.util.Set<software.amazon.smithy.model.shapes.EnumShape> getEnumShapes()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets an immutable set of all enums in the Model.
  ///@return Returns the Set of {@code enum}s.
  jni.JObject getEnumShapes() {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference, _id_getEnumShapes, jni.JniCallType.objectType, []).object);
  }

  static final _id_getEnumShapesWithTrait = jniAccessors.getMethodIDOf(
      _classRef,
      r"getEnumShapesWithTrait",
      r"(Ljava/lang/Class;)Ljava/util/Set;");

  /// from: public java.util.Set<software.amazon.smithy.model.shapes.EnumShape> getEnumShapesWithTrait(java.lang.Class<? extends software.amazon.smithy.model.traits.Trait> trait)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets an immutable set of all enums in the Model that have a specific trait.
  ///@param trait The exact trait class to look for on shapes.
  ///@return Returns the set of {@code enum}s that have a specific trait.
  jni.JObject getEnumShapesWithTrait(
    jni.JObject trait,
  ) {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_getEnumShapesWithTrait,
        jni.JniCallType.objectType,
        [trait.reference]).object);
  }

  static final _id_getStructureShapes = jniAccessors.getMethodIDOf(
      _classRef, r"getStructureShapes", r"()Ljava/util/Set;");

  /// from: public java.util.Set<software.amazon.smithy.model.shapes.StructureShape> getStructureShapes()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets an immutable set of all structures in the Model.
  ///@return Returns the Set of {@code structure}s.
  jni.JObject getStructureShapes() {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_getStructureShapes,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_getStructureShapesWithTrait = jniAccessors.getMethodIDOf(
      _classRef,
      r"getStructureShapesWithTrait",
      r"(Ljava/lang/Class;)Ljava/util/Set;");

  /// from: public java.util.Set<software.amazon.smithy.model.shapes.StructureShape> getStructureShapesWithTrait(java.lang.Class<? extends software.amazon.smithy.model.traits.Trait> trait)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets an immutable set of all structures in the Model that have a specific trait.
  ///@param trait The exact trait class to look for on shapes.
  ///@return Returns the set of {@code structure}s that have a specific trait.
  jni.JObject getStructureShapesWithTrait(
    jni.JObject trait,
  ) {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_getStructureShapesWithTrait,
        jni.JniCallType.objectType,
        [trait.reference]).object);
  }

  static final _id_getTimestampShapes = jniAccessors.getMethodIDOf(
      _classRef, r"getTimestampShapes", r"()Ljava/util/Set;");

  /// from: public java.util.Set<software.amazon.smithy.model.shapes.TimestampShape> getTimestampShapes()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets an immutable set of all timestamps in the Model.
  ///@return Returns the Set of {@code timestamp}s.
  jni.JObject getTimestampShapes() {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_getTimestampShapes,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_getTimestampShapesWithTrait = jniAccessors.getMethodIDOf(
      _classRef,
      r"getTimestampShapesWithTrait",
      r"(Ljava/lang/Class;)Ljava/util/Set;");

  /// from: public java.util.Set<software.amazon.smithy.model.shapes.TimestampShape> getTimestampShapesWithTrait(java.lang.Class<? extends software.amazon.smithy.model.traits.Trait> trait)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets an immutable set of all timestamps in the Model that have a specific trait.
  ///@param trait The exact trait class to look for on shapes.
  ///@return Returns the set of {@code timestamp}s that have a specific trait.
  jni.JObject getTimestampShapesWithTrait(
    jni.JObject trait,
  ) {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_getTimestampShapesWithTrait,
        jni.JniCallType.objectType,
        [trait.reference]).object);
  }

  static final _id_getUnionShapes = jniAccessors.getMethodIDOf(
      _classRef, r"getUnionShapes", r"()Ljava/util/Set;");

  /// from: public java.util.Set<software.amazon.smithy.model.shapes.UnionShape> getUnionShapes()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets an immutable set of all unions in the Model.
  ///@return Returns the Set of {@code union}s.
  jni.JObject getUnionShapes() {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference, _id_getUnionShapes, jni.JniCallType.objectType, []).object);
  }

  static final _id_getUnionShapesWithTrait = jniAccessors.getMethodIDOf(
      _classRef,
      r"getUnionShapesWithTrait",
      r"(Ljava/lang/Class;)Ljava/util/Set;");

  /// from: public java.util.Set<software.amazon.smithy.model.shapes.UnionShape> getUnionShapesWithTrait(java.lang.Class<? extends software.amazon.smithy.model.traits.Trait> trait)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets an immutable set of all unions in the Model that have a specific trait.
  ///@param trait The exact trait class to look for on shapes.
  ///@return Returns the set of {@code union}s that have a specific trait.
  jni.JObject getUnionShapesWithTrait(
    jni.JObject trait,
  ) {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_getUnionShapesWithTrait,
        jni.JniCallType.objectType,
        [trait.reference]).object);
  }

  static final _id_getAppliedTraits = jniAccessors.getMethodIDOf(
      _classRef, r"getAppliedTraits", r"()Ljava/util/Set;");

  /// from: public java.util.Set<software.amazon.smithy.model.shapes.ShapeId> getAppliedTraits()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets a set of every trait shape ID that is used in the model.
  ///@return Returns the shape IDs of traits used in the model.
  jni.JObject getAppliedTraits() {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_getAppliedTraits,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_isTraitApplied = jniAccessors.getMethodIDOf(
      _classRef, r"isTraitApplied", r"(Ljava/lang/Class;)Z");

  /// from: public boolean isTraitApplied(java.lang.Class<? extends software.amazon.smithy.model.traits.Trait> trait)
  ///
  /// Returns true if the given trait shape ID was used in the model.
  ///@param trait The trait class to check.
  ///@return Returns true if the trait was used in the model.
  bool isTraitApplied(
    jni.JObject trait,
  ) {
    return jniAccessors.callMethodWithArgs(reference, _id_isTraitApplied,
        jni.JniCallType.booleanType, [trait.reference]).boolean;
  }

  static final _id_getShape = jniAccessors.getMethodIDOf(_classRef, r"getShape",
      r"(Lsoftware/amazon/smithy/model/shapes/ShapeId;)Ljava/util/Optional;");

  /// from: public java.util.Optional<software.amazon.smithy.model.shapes.Shape> getShape(software.amazon.smithy.model.shapes.ShapeId id)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Attempts to retrieve a Shape by ShapeId.
  ///@param id Shape to retrieve by ID.
  ///@return Returns the optional shape.
  jni.JObject getShape(
    jni.JObject id,
  ) {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_getShape,
        jni.JniCallType.objectType,
        [id.reference]).object);
  }

  static final _id_expectShape = jniAccessors.getMethodIDOf(
      _classRef,
      r"expectShape",
      r"(Lsoftware/amazon/smithy/model/shapes/ShapeId;)Lsoftware/amazon/smithy/model/shapes/Shape;");

  /// from: public software.amazon.smithy.model.shapes.Shape expectShape(software.amazon.smithy.model.shapes.ShapeId id)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Attempts to retrieve a Shape by ShapeId and
  /// throws if not found.
  ///@param id Shape to retrieve by ID.
  ///@return Returns the shape.
  ///@throws ExpectationNotMetException if the shape is not found.
  jni.JObject expectShape(
    jni.JObject id,
  ) {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_expectShape,
        jni.JniCallType.objectType,
        [id.reference]).object);
  }

  static final _id_expectShape1 = jniAccessors.getMethodIDOf(
      _classRef,
      r"expectShape",
      r"(Lsoftware/amazon/smithy/model/shapes/ShapeId;Ljava/lang/Class;)Ljava/lang/Object;");

  /// from: public T expectShape(software.amazon.smithy.model.shapes.ShapeId id, java.lang.Class<T> type)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Attempts to retrieve a Shape by ShapeId and
  /// throws if not found or if the shape is not of the expected type.
  ///@param id Shape to retrieve by ID.
  ///@param type Shape type to expect and convert to.
  ///@param <T> Expected shape type.
  ///@return Returns the shape.
  ///@throws ExpectationNotMetException if the shape is not found or is not the expected type.
  $T expectShape1<$T extends jni.JObject>(
    jni.JObject id,
    jni.JObject type, {
    required jni.JObjType<$T> T,
  }) {
    return T.fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_expectShape1,
        jni.JniCallType.objectType,
        [id.reference, type.reference]).object);
  }

  static final _id_shapes = jniAccessors.getMethodIDOf(
      _classRef, r"shapes", r"()Ljava/util/stream/Stream;");

  /// from: public java.util.stream.Stream<software.amazon.smithy.model.shapes.Shape> shapes()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets a stream of Shapes in the index.
  ///@return Returns a stream of shapes.
  jni.JObject shapes() {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference, _id_shapes, jni.JniCallType.objectType, []).object);
  }

  static final _id_shapes1 = jniAccessors.getMethodIDOf(
      _classRef, r"shapes", r"(Ljava/lang/Class;)Ljava/util/stream/Stream;");

  /// from: public java.util.stream.Stream<T> shapes(java.lang.Class<T> shapeType)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets a stream of shapes in the index of a specific type {@code T}.
  ///
  /// The provided shapeType class must exactly match the class of a
  /// shape in the model in order to be returned from this method;
  /// that is, the provided class must be a concrete subclass of
  /// Shape and not an abstract class like NumberShape.
  ///@param shapeType Shape type {@code T} to retrieve.
  ///@param <T> Shape type to stream from the index.
  ///@return A stream of shapes of {@code T} matching {@code shapeType}.
  jni.JObject shapes1<$T extends jni.JObject>(
    jni.JObject shapeType, {
    required jni.JObjType<$T> T,
  }) {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_shapes1,
        jni.JniCallType.objectType,
        [shapeType.reference]).object);
  }

  static final _id_toSet = jniAccessors.getMethodIDOf(
      _classRef, r"toSet", r"(Ljava/lang/Class;)Ljava/util/Set;");

  /// from: public java.util.Set<T> toSet(java.lang.Class<T> shapeType)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets an immutable Set of shapes of a specific type.
  ///@param shapeType Type of shape to get a set of.
  ///@param <T> Shape type to get from the index.
  ///@return Returns an unmodifiable set of shapes.
  jni.JObject toSet<$T extends jni.JObject>(
    jni.JObject shapeType, {
    required jni.JObjType<$T> T,
  }) {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_toSet,
        jni.JniCallType.objectType,
        [shapeType.reference]).object);
  }

  static final _id_toSet1 =
      jniAccessors.getMethodIDOf(_classRef, r"toSet", r"()Ljava/util/Set;");

  /// from: public java.util.Set<software.amazon.smithy.model.shapes.Shape> toSet()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Converts the model to an immutable Set of shapes.
  ///@return Returns an unmodifiable set of shapes.
  jni.JObject toSet1() {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference, _id_toSet1, jni.JniCallType.objectType, []).object);
  }

  static final _id_equals1 = jniAccessors.getMethodIDOf(
      _classRef, r"equals", r"(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object other)
  bool equals1(
    jni.JObject other,
  ) {
    return jniAccessors.callMethodWithArgs(reference, _id_equals1,
        jni.JniCallType.booleanType, [other.reference]).boolean;
  }

  static final _id_hashCode1 =
      jniAccessors.getMethodIDOf(_classRef, r"hashCode", r"()I");

  /// from: public int hashCode()
  int hashCode1() {
    return jniAccessors.callMethodWithArgs(
        reference, _id_hashCode1, jni.JniCallType.intType, []).integer;
  }

  static final _id_toBuilder = jniAccessors.getMethodIDOf(_classRef,
      r"toBuilder", r"()Lsoftware/amazon/smithy/model/Model$Builder;");

  /// from: public software.amazon.smithy.model.Model.Builder toBuilder()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Model_Builder toBuilder() {
    return const $Model_BuilderType().fromRef(jniAccessors.callMethodWithArgs(
        reference, _id_toBuilder, jni.JniCallType.objectType, []).object);
  }

  static final _id_getKnowledge = jniAccessors.getMethodIDOf(
      _classRef, r"getKnowledge", r"(Ljava/lang/Class;)Ljava/lang/Object;");

  /// from: public T getKnowledge(java.lang.Class<T> type)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This method is deprecated. Use the {@code of} method of the
  /// KnowledgeIndex you wish to create instead.
  ///@param type Type of knowledge index to retrieve.
  ///@param <T> The type of knowledge index to retrieve.
  ///@return Returns the computed knowledge index.
  $T getKnowledge<$T extends jni.JObject>(
    jni.JObject type, {
    required jni.JObjType<$T> T,
  }) {
    return T.fromRef(jniAccessors.callMethodWithArgs(reference,
        _id_getKnowledge, jni.JniCallType.objectType, [type.reference]).object);
  }

  static final _id_getKnowledge1 = jniAccessors.getMethodIDOf(
      _classRef,
      r"getKnowledge",
      r"(Ljava/lang/Class;Ljava/util/function/Function;)Ljava/lang/Object;");

  /// from: public T getKnowledge(java.lang.Class<T> type, java.util.function.Function<software.amazon.smithy.model.Model,T> constructor)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets a computed "knowledge index" of a specific type for the model
  /// and caches it for subsequent retrieval.
  ///
  /// This method should not typically be called directly because
  /// KnowledgeIndex classes should all provide a public static {@code of}
  /// method that accepts a {@code Model} and returns an instance of the
  /// index by invoking {@code getKnowledge}.
  ///
  /// If a KnowledgeIndex of the given type has not yet been
  /// computed, one will be created using the provided {@code constructor}
  /// function that accepts a Model. Computed knowledge indexes are
  /// cached and returned on subsequent retrievals.
  ///@param type Type of knowledge index to retrieve.
  ///@param constructor The method used to create {@code type}.
  ///@param <T> The type of knowledge index to retrieve.
  ///@return Returns the computed knowledge index.
  $T getKnowledge1<$T extends jni.JObject>(
    jni.JObject type,
    jni.JObject constructor, {
    required jni.JObjType<$T> T,
  }) {
    return T.fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_getKnowledge1,
        jni.JniCallType.objectType,
        [type.reference, constructor.reference]).object);
  }
}

class $ModelType extends jni.JObjType<Model> {
  const $ModelType();

  @override
  String get signature => r"Lsoftware/amazon/smithy/model/Model;";

  @override
  Model fromRef(jni.JObjectPtr ref) => Model.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ModelType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == $ModelType && other is $ModelType;
  }
}

/// from: software.amazon.smithy.model.Model$Builder
///
/// Builder used to create a Model.
class Model_Builder extends jni.JObject {
  @override
  late final jni.JObjType $type = type;

  Model_Builder.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _classRef =
      jniAccessors.getClassOf(r"software/amazon/smithy/model/Model$Builder");

  /// The type which includes information such as the signature of this class.
  static const type = $Model_BuilderType();
  static final _id_metadata = jniAccessors.getMethodIDOf(_classRef, r"metadata",
      r"(Ljava/util/Map;)Lsoftware/amazon/smithy/model/Model$Builder;");

  /// from: public software.amazon.smithy.model.Model.Builder metadata(java.util.Map<java.lang.String,software.amazon.smithy.model.node.Node> metadata)
  /// The returned object must be deleted after use, by calling the `delete` method.
  Model_Builder metadata(
    jni.JObject metadata,
  ) {
    return const $Model_BuilderType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_metadata,
        jni.JniCallType.objectType,
        [metadata.reference]).object);
  }

  static final _id_putMetadataProperty = jniAccessors.getMethodIDOf(
      _classRef,
      r"putMetadataProperty",
      r"(Ljava/lang/String;Lsoftware/amazon/smithy/model/node/Node;)Lsoftware/amazon/smithy/model/Model$Builder;");

  /// from: public software.amazon.smithy.model.Model.Builder putMetadataProperty(java.lang.String key, software.amazon.smithy.model.node.Node value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  Model_Builder putMetadataProperty(
    jni.JString key,
    Node value,
  ) {
    return const $Model_BuilderType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_putMetadataProperty,
        jni.JniCallType.objectType,
        [key.reference, value.reference]).object);
  }

  static final _id_removeMetadataProperty = jniAccessors.getMethodIDOf(
      _classRef,
      r"removeMetadataProperty",
      r"(Ljava/lang/String;)Lsoftware/amazon/smithy/model/Model$Builder;");

  /// from: public software.amazon.smithy.model.Model.Builder removeMetadataProperty(java.lang.String key)
  /// The returned object must be deleted after use, by calling the `delete` method.
  Model_Builder removeMetadataProperty(
    jni.JString key,
  ) {
    return const $Model_BuilderType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_removeMetadataProperty,
        jni.JniCallType.objectType,
        [key.reference]).object);
  }

  static final _id_clearMetadata = jniAccessors.getMethodIDOf(_classRef,
      r"clearMetadata", r"()Lsoftware/amazon/smithy/model/Model$Builder;");

  /// from: public software.amazon.smithy.model.Model.Builder clearMetadata()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Model_Builder clearMetadata() {
    return const $Model_BuilderType().fromRef(jniAccessors.callMethodWithArgs(
        reference, _id_clearMetadata, jni.JniCallType.objectType, []).object);
  }

  static final _id_addShape = jniAccessors.getMethodIDOf(_classRef, r"addShape",
      r"(Lsoftware/amazon/smithy/model/shapes/Shape;)Lsoftware/amazon/smithy/model/Model$Builder;");

  /// from: public software.amazon.smithy.model.Model.Builder addShape(software.amazon.smithy.model.shapes.Shape shape)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add a shape to the builder.
  ///
  /// MemberShape shapes are not added to the model directly.
  /// They must be added by adding their containing shapes (e.g., to add a
  /// list member, you must add the list shape that contains it). Any member
  /// shape provided to any of the methods used to add shapes to the
  /// model are ignored.
  ///@param shape Shape to add.
  ///@return Returns the builder.
  Model_Builder addShape(
    jni.JObject shape,
  ) {
    return const $Model_BuilderType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_addShape,
        jni.JniCallType.objectType,
        [shape.reference]).object);
  }

  static final _id_addShapes = jniAccessors.getMethodIDOf(
      _classRef,
      r"addShapes",
      r"(Lsoftware/amazon/smithy/model/Model;)Lsoftware/amazon/smithy/model/Model$Builder;");

  /// from: public software.amazon.smithy.model.Model.Builder addShapes(software.amazon.smithy.model.Model model)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Adds the shapes of another model to the builder.
  ///@param model Model to add shapes from.
  ///@return Returns the builder.
  Model_Builder addShapes(
    Model model,
  ) {
    return const $Model_BuilderType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_addShapes,
        jni.JniCallType.objectType,
        [model.reference]).object);
  }

  static final _id_addShapes1 = jniAccessors.getMethodIDOf(
      _classRef,
      r"addShapes",
      r"(Ljava/util/Collection;)Lsoftware/amazon/smithy/model/Model$Builder;");

  /// from: public software.amazon.smithy.model.Model.Builder addShapes(java.util.Collection<S> shapes)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Adds a collection of shapes to the builder.
  ///@param shapes Collection of Shapes to add.
  ///@param <S> Type of shape being added.
  ///@return Returns the builder.
  Model_Builder addShapes1<$S extends jni.JObject>(
    jni.JObject shapes, {
    required jni.JObjType<$S> S,
  }) {
    return const $Model_BuilderType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_addShapes1,
        jni.JniCallType.objectType,
        [shapes.reference]).object);
  }

  static final _id_addShapes2 = jniAccessors.getMethodIDOf(
      _classRef,
      r"addShapes",
      r"([Lsoftware/amazon/smithy/model/shapes/Shape;)Lsoftware/amazon/smithy/model/Model$Builder;");

  /// from: public software.amazon.smithy.model.Model.Builder addShapes(software.amazon.smithy.model.shapes.Shape[] shapes)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Adds a variadic list of shapes.
  ///@param shapes Shapes to add.
  ///@return Returns the builder.
  Model_Builder addShapes2(
    jni.JArray<jni.JObject> shapes,
  ) {
    return const $Model_BuilderType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_addShapes2,
        jni.JniCallType.objectType,
        [shapes.reference]).object);
  }

  static final _id_removeShape = jniAccessors.getMethodIDOf(
      _classRef,
      r"removeShape",
      r"(Lsoftware/amazon/smithy/model/shapes/ShapeId;)Lsoftware/amazon/smithy/model/Model$Builder;");

  /// from: public software.amazon.smithy.model.Model.Builder removeShape(software.amazon.smithy.model.shapes.ShapeId shapeId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Removes a shape from the builder by ID.
  ///
  /// Members of shapes are automatically removed when their
  /// containing shape is removed.
  ///@param shapeId Shape to remove.
  ///@return Returns the builder.
  Model_Builder removeShape(
    jni.JObject shapeId,
  ) {
    return const $Model_BuilderType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_removeShape,
        jni.JniCallType.objectType,
        [shapeId.reference]).object);
  }

  static final _id_getCurrentShapes = jniAccessors.getMethodIDOf(
      _classRef, r"getCurrentShapes", r"()Ljava/util/Map;");

  /// from: public java.util.Map<software.amazon.smithy.model.shapes.ShapeId,software.amazon.smithy.model.shapes.Shape> getCurrentShapes()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets an immutable view of the current shapes in the builder.
  ///
  /// The returned view may not be updated as shapes are added to the builder.
  ///@return Returns the current shapes in the builder.
  jni.JObject getCurrentShapes() {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_getCurrentShapes,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_build = jniAccessors.getMethodIDOf(
      _classRef, r"build", r"()Lsoftware/amazon/smithy/model/Model;");

  /// from: public software.amazon.smithy.model.Model build()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Model build() {
    return const $ModelType().fromRef(jniAccessors.callMethodWithArgs(
        reference, _id_build, jni.JniCallType.objectType, []).object);
  }
}

class $Model_BuilderType extends jni.JObjType<Model_Builder> {
  const $Model_BuilderType();

  @override
  String get signature => r"Lsoftware/amazon/smithy/model/Model$Builder;";

  @override
  Model_Builder fromRef(jni.JObjectPtr ref) => Model_Builder.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Model_BuilderType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == $Model_BuilderType &&
        other is $Model_BuilderType;
  }
}

/// from: software.amazon.smithy.model.loader.ModelAssembler
///
/// Assembles and validates a Model from documents, files, shapes, and
/// other sources.
///
/// Validation vents are aggregated into a Set to ensure that
/// duplicate events are not emitted.
///
/// Smithy models found on the class path can be discovered using
/// _model discovery_. Model discovery must be explicitly requested of
/// a {@code ModelAssembler} by invoking \#discoverModels() or
/// \#discoverModels(ClassLoader).
///@see Model\#assembler()
class ModelAssembler extends jni.JObject {
  @override
  late final jni.JObjType $type = type;

  ModelAssembler.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _classRef = jniAccessors
      .getClassOf(r"software/amazon/smithy/model/loader/ModelAssembler");

  /// The type which includes information such as the signature of this class.
  static const type = $ModelAssemblerType();

  /// from: static public final java.lang.String ALLOW_UNKNOWN_TRAITS
  ///
  /// Allow unknown traits rather than fail.
  static const ALLOW_UNKNOWN_TRAITS = r"""assembler.allowUnknownTraits""";

  /// from: static public final java.lang.String DISABLE_JAR_CACHE
  ///
  /// Sets URLConnection\#setUseCaches to false.
  ///
  /// When running in a build environment, using caches can cause exceptions
  /// like `java.util.zip.ZipException: ZipFile invalid LOC header (bad signature)`
  /// because a previously loaded JAR might change between builds. The
  /// "assembler.disableJarCache" setting should be set to true when embedding
  /// Smithy into an environment where this can occur.
  static const DISABLE_JAR_CACHE = r"""assembler.disableJarCache""";

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, r"<init>", r"()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  factory ModelAssembler() {
    return ModelAssembler.fromRef(
        jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);
  }

  static final _id_copy = jniAccessors.getMethodIDOf(_classRef, r"copy",
      r"()Lsoftware/amazon/smithy/model/loader/ModelAssembler;");

  /// from: public software.amazon.smithy.model.loader.ModelAssembler copy()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a copy of the current model assembler.
  ///@return Returns the created model assembler copy.
  ModelAssembler copy() {
    return const $ModelAssemblerType().fromRef(jniAccessors.callMethodWithArgs(
        reference, _id_copy, jni.JniCallType.objectType, []).object);
  }

  static final _id_reset = jniAccessors.getMethodIDOf(_classRef, r"reset",
      r"()Lsoftware/amazon/smithy/model/loader/ModelAssembler;");

  /// from: public software.amazon.smithy.model.loader.ModelAssembler reset()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Resets the state of the ModelAssembler.
  ///
  /// The following properties of the ModelAssembler are cleared when
  /// this method is called:
  ///
  /// <ul>
  ///     <li>Validators registered via \#addValidator</li>
  ///     <li>Models registered via \#addImport</li>
  ///     <li>Models registered via \#addDocumentNode</li>
  ///     <li>Models registered via \#addUnparsedModel</li>
  ///     <li>Models registered via \#addModel</li>
  ///     <li>Shape registered via \#addModel</li>
  ///     <li>Metadata registered via \#putMetadata</li>
  ///     <li>Validation is re-enabled if it was disabled.</li>
  ///     <li>Validation event listener via \#validationEventListener(Consumer)</li>
  /// </ul>
  ///
  /// The state of \#disablePrelude is reset such that the prelude
  /// is no longer disabled after calling {@code reset}.
  ///@return Returns the model assembler.
  ModelAssembler reset() {
    return const $ModelAssemblerType().fromRef(jniAccessors.callMethodWithArgs(
        reference, _id_reset, jni.JniCallType.objectType, []).object);
  }

  static final _id_traitFactory = jniAccessors.getMethodIDOf(
      _classRef,
      r"traitFactory",
      r"(Lsoftware/amazon/smithy/model/traits/TraitFactory;)Lsoftware/amazon/smithy/model/loader/ModelAssembler;");

  /// from: public software.amazon.smithy.model.loader.ModelAssembler traitFactory(software.amazon.smithy.model.traits.TraitFactory traitFactory)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Uses a custom TraitFactory to resolve and configure traits.
  ///@param traitFactory Trait factory to use instead of the default.
  ///@return Returns the assembler.
  ModelAssembler traitFactory(
    jni.JObject traitFactory,
  ) {
    return const $ModelAssemblerType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_traitFactory,
        jni.JniCallType.objectType,
        [traitFactory.reference]).object);
  }

  static final _id_validatorFactory = jniAccessors.getMethodIDOf(
      _classRef,
      r"validatorFactory",
      r"(Lsoftware/amazon/smithy/model/validation/ValidatorFactory;)Lsoftware/amazon/smithy/model/loader/ModelAssembler;");

  /// from: public software.amazon.smithy.model.loader.ModelAssembler validatorFactory(software.amazon.smithy.model.validation.ValidatorFactory validatorFactory)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets a custom ValidatorFactory used to dynamically resolve
  /// validator definitions.
  ///
  /// Note that if you do not provide an explicit validatorFactory, a
  /// default factory is utilized that uses service discovery.
  ///@param validatorFactory Validator factory to use.
  ///@return Returns the assembler.
  ModelAssembler validatorFactory(
    jni.JObject validatorFactory,
  ) {
    return const $ModelAssemblerType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_validatorFactory,
        jni.JniCallType.objectType,
        [validatorFactory.reference]).object);
  }

  static final _id_addValidator = jniAccessors.getMethodIDOf(
      _classRef,
      r"addValidator",
      r"(Lsoftware/amazon/smithy/model/validation/Validator;)Lsoftware/amazon/smithy/model/loader/ModelAssembler;");

  /// from: public software.amazon.smithy.model.loader.ModelAssembler addValidator(software.amazon.smithy.model.validation.Validator validator)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Registers a validator to be used when validating the model.
  ///@param validator Validator to register.
  ///@return Returns the assembler.
  ModelAssembler addValidator(
    jni.JObject validator,
  ) {
    return const $ModelAssemblerType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_addValidator,
        jni.JniCallType.objectType,
        [validator.reference]).object);
  }

  static final _id_addUnparsedModel = jniAccessors.getMethodIDOf(
      _classRef,
      r"addUnparsedModel",
      r"(Ljava/lang/String;Ljava/lang/String;)Lsoftware/amazon/smithy/model/loader/ModelAssembler;");

  /// from: public software.amazon.smithy.model.loader.ModelAssembler addUnparsedModel(java.lang.String sourceLocation, java.lang.String model)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Adds a string containing an unparsed model to the assembler.
  ///
  /// The provided {@code sourceLocation} string must end with
  /// ".json" or ".smithy" to be parsed correctly.
  ///@param sourceLocation Source location to assume for the unparsed content.
  ///@param model Unparsed model source.
  ///@return Returns the assembler.
  ModelAssembler addUnparsedModel(
    jni.JString sourceLocation,
    jni.JString model,
  ) {
    return const $ModelAssemblerType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_addUnparsedModel,
        jni.JniCallType.objectType,
        [sourceLocation.reference, model.reference]).object);
  }

  static final _id_addDocumentNode = jniAccessors.getMethodIDOf(
      _classRef,
      r"addDocumentNode",
      r"(Lsoftware/amazon/smithy/model/node/Node;)Lsoftware/amazon/smithy/model/loader/ModelAssembler;");

  /// from: public software.amazon.smithy.model.loader.ModelAssembler addDocumentNode(software.amazon.smithy.model.node.Node document)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Adds a parsed JSON model file as a Node to the assembler.
  ///@param document Parsed document node to add.
  ///@return Returns the assembler.
  ModelAssembler addDocumentNode(
    Node document,
  ) {
    return const $ModelAssemblerType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_addDocumentNode,
        jni.JniCallType.objectType,
        [document.reference]).object);
  }

  static final _id_addImport = jniAccessors.getMethodIDOf(
      _classRef,
      r"addImport",
      r"(Ljava/lang/String;)Lsoftware/amazon/smithy/model/loader/ModelAssembler;");

  /// from: public software.amazon.smithy.model.loader.ModelAssembler addImport(java.lang.String importPath)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Adds an import to the assembler.
  ///@param importPath Import path to add.
  ///@return Returns the assembler.
  ///@see \#addImport(Path)
  ModelAssembler addImport(
    jni.JString importPath,
  ) {
    return const $ModelAssemblerType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_addImport,
        jni.JniCallType.objectType,
        [importPath.reference]).object);
  }

  static final _id_addImport1 = jniAccessors.getMethodIDOf(
      _classRef,
      r"addImport",
      r"(Ljava/nio/file/Path;)Lsoftware/amazon/smithy/model/loader/ModelAssembler;");

  /// from: public software.amazon.smithy.model.loader.ModelAssembler addImport(java.nio.file.Path importPath)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Adds an import to the assembler.
  ///
  /// If a directory is found, all ".json" and ".ion" files that contain
  /// a "smithy" key-value pair found in the directory and any subdirectories
  /// are imported into the model.
  ///@param importPath Import path to add.
  ///@return Returns the assembler.
  ModelAssembler addImport1(
    jni.JObject importPath,
  ) {
    return const $ModelAssemblerType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_addImport1,
        jni.JniCallType.objectType,
        [importPath.reference]).object);
  }

  static final _id_addImport2 = jniAccessors.getMethodIDOf(
      _classRef,
      r"addImport",
      r"(Ljava/net/URL;)Lsoftware/amazon/smithy/model/loader/ModelAssembler;");

  /// from: public software.amazon.smithy.model.loader.ModelAssembler addImport(java.net.URL url)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Adds an import to the assembler from a URL.
  ///
  /// The provided URL can point to a .json model, .smithy model, or
  /// a .jar file that contains Smithy models.
  ///
  /// <pre>
  /// {@code
  /// Model model = Model.assembler()
  ///      .addImport(getClass().getClassLoader().getResource("model.json"))
  ///      .assemble()
  ///      .unwrap();
  /// }
  /// </pre>
  ///@param url Resource URL to load and add.
  ///@return Returns the assembler.
  ModelAssembler addImport2(
    jni.JObject url,
  ) {
    return const $ModelAssemblerType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_addImport2,
        jni.JniCallType.objectType,
        [url.reference]).object);
  }

  static final _id_disablePrelude = jniAccessors.getMethodIDOf(
      _classRef,
      r"disablePrelude",
      r"()Lsoftware/amazon/smithy/model/loader/ModelAssembler;");

  /// from: public software.amazon.smithy.model.loader.ModelAssembler disablePrelude()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Disables automatically loading the prelude models.
  ///@return Returns the assembler.
  ModelAssembler disablePrelude() {
    return const $ModelAssemblerType().fromRef(jniAccessors.callMethodWithArgs(
        reference, _id_disablePrelude, jni.JniCallType.objectType, []).object);
  }

  static final _id_addShape = jniAccessors.getMethodIDOf(_classRef, r"addShape",
      r"(Lsoftware/amazon/smithy/model/shapes/Shape;)Lsoftware/amazon/smithy/model/loader/ModelAssembler;");

  /// from: public software.amazon.smithy.model.loader.ModelAssembler addShape(software.amazon.smithy.model.shapes.Shape shape)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Explicitly injects a shape into the assembled model.
  ///@param shape Shape to add.
  ///@return Returns the assembler.
  ModelAssembler addShape(
    jni.JObject shape,
  ) {
    return const $ModelAssemblerType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_addShape,
        jni.JniCallType.objectType,
        [shape.reference]).object);
  }

  static final _id_addShapes = jniAccessors.getMethodIDOf(
      _classRef,
      r"addShapes",
      r"([Lsoftware/amazon/smithy/model/shapes/Shape;)Lsoftware/amazon/smithy/model/loader/ModelAssembler;");

  /// from: public software.amazon.smithy.model.loader.ModelAssembler addShapes(software.amazon.smithy.model.shapes.Shape[] shapes)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Explicitly injects multiple shapes into the assembled model.
  ///@param shapes Shapes to add.
  ///@return Returns the assembler.
  ModelAssembler addShapes(
    jni.JArray<jni.JObject> shapes,
  ) {
    return const $ModelAssemblerType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_addShapes,
        jni.JniCallType.objectType,
        [shapes.reference]).object);
  }

  static final _id_addTrait = jniAccessors.getMethodIDOf(_classRef, r"addTrait",
      r"(Lsoftware/amazon/smithy/model/shapes/ShapeId;Lsoftware/amazon/smithy/model/traits/Trait;)Lsoftware/amazon/smithy/model/loader/ModelAssembler;");

  /// from: public software.amazon.smithy.model.loader.ModelAssembler addTrait(software.amazon.smithy.model.shapes.ShapeId target, software.amazon.smithy.model.traits.Trait trait)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Explicitly adds a trait to a shape in the assembled model.
  ///@param target Shape to add the trait to.
  ///@param trait Trait to add.
  ///@return Returns the assembler.
  ModelAssembler addTrait(
    jni.JObject target,
    jni.JObject trait,
  ) {
    return const $ModelAssemblerType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_addTrait,
        jni.JniCallType.objectType,
        [target.reference, trait.reference]).object);
  }

  static final _id_addModel = jniAccessors.getMethodIDOf(_classRef, r"addModel",
      r"(Lsoftware/amazon/smithy/model/Model;)Lsoftware/amazon/smithy/model/loader/ModelAssembler;");

  /// from: public software.amazon.smithy.model.loader.ModelAssembler addModel(software.amazon.smithy.model.Model model)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Merges a loaded model into the model assembler.
  ///@param model Model to merge in.
  ///@return Returns the model assembler.
  ModelAssembler addModel(
    Model model,
  ) {
    return const $ModelAssemblerType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_addModel,
        jni.JniCallType.objectType,
        [model.reference]).object);
  }

  static final _id_putMetadata = jniAccessors.getMethodIDOf(
      _classRef,
      r"putMetadata",
      r"(Ljava/lang/String;Lsoftware/amazon/smithy/model/node/Node;)Lsoftware/amazon/smithy/model/loader/ModelAssembler;");

  /// from: public software.amazon.smithy.model.loader.ModelAssembler putMetadata(java.lang.String name, software.amazon.smithy.model.node.Node value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Adds metadata to the model.
  ///@param name Metadata key to set.
  ///@param value Metadata value to set.
  ///@return Returns the model assembler.
  ModelAssembler putMetadata(
    jni.JString name,
    Node value,
  ) {
    return const $ModelAssemblerType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_putMetadata,
        jni.JniCallType.objectType,
        [name.reference, value.reference]).object);
  }

  static final _id_discoverModels = jniAccessors.getMethodIDOf(
      _classRef,
      r"discoverModels",
      r"(Ljava/lang/ClassLoader;)Lsoftware/amazon/smithy/model/loader/ModelAssembler;");

  /// from: public software.amazon.smithy.model.loader.ModelAssembler discoverModels(java.lang.ClassLoader loader)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Discovers models by merging in all models returns by ModelDiscovery
  /// manifests using the provided {@code ClassLoader}.
  ///@param loader Class loader to use to discover models.
  ///@return Returns the model assembler.
  ModelAssembler discoverModels(
    jni.JObject loader,
  ) {
    return const $ModelAssemblerType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_discoverModels,
        jni.JniCallType.objectType,
        [loader.reference]).object);
  }

  static final _id_discoverModels1 = jniAccessors.getMethodIDOf(
      _classRef,
      r"discoverModels",
      r"()Lsoftware/amazon/smithy/model/loader/ModelAssembler;");

  /// from: public software.amazon.smithy.model.loader.ModelAssembler discoverModels()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Discovers models by merging in all models returns by ModelDiscovery
  /// manifests using the thread context {@code ClassLoader}.
  ///@return Returns the model assembler.
  ModelAssembler discoverModels1() {
    return const $ModelAssemblerType().fromRef(jniAccessors.callMethodWithArgs(
        reference, _id_discoverModels1, jni.JniCallType.objectType, []).object);
  }

  static final _id_putProperty = jniAccessors.getMethodIDOf(
      _classRef,
      r"putProperty",
      r"(Ljava/lang/String;Ljava/lang/Object;)Lsoftware/amazon/smithy/model/loader/ModelAssembler;");

  /// from: public software.amazon.smithy.model.loader.ModelAssembler putProperty(java.lang.String setting, java.lang.Object value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Puts a configuration property on the ModelAssembler.
  ///
  /// Any number of properties can be given to the model assembler to
  /// affect how models are loaded. Some properties like \#ALLOW_UNKNOWN_TRAITS
  /// are built-in properties, while other properties can be custom
  /// properties that are specific to certain ModelLoader
  /// implementations.
  ///
  /// The following example configures the ModelAssembler to emit warnings
  /// for unknown traits rather than fail:
  ///
  /// <pre>{@code
  /// ModelAssembler assembler = Model.assembler();
  /// assembler.putProperty(ModelAssembler.ALLOW_UNKNOWN_TRAITS, true);
  /// }</pre>
  ///@param setting Name of the property to put.
  ///@param value Value to set for the property.
  ///@return Returns the assembler.
  ModelAssembler putProperty(
    jni.JString setting,
    jni.JObject value,
  ) {
    return const $ModelAssemblerType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_putProperty,
        jni.JniCallType.objectType,
        [setting.reference, value.reference]).object);
  }

  static final _id_removeProperty = jniAccessors.getMethodIDOf(
      _classRef,
      r"removeProperty",
      r"(Ljava/lang/String;)Lsoftware/amazon/smithy/model/loader/ModelAssembler;");

  /// from: public software.amazon.smithy.model.loader.ModelAssembler removeProperty(java.lang.String setting)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Removes a setting from the ModelAssembler.
  ///@param setting Setting to remove.
  ///@return Returns the assembler.
  ModelAssembler removeProperty(
    jni.JString setting,
  ) {
    return const $ModelAssemblerType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_removeProperty,
        jni.JniCallType.objectType,
        [setting.reference]).object);
  }

  static final _id_disableValidation = jniAccessors.getMethodIDOf(
      _classRef,
      r"disableValidation",
      r"()Lsoftware/amazon/smithy/model/loader/ModelAssembler;");

  /// from: public software.amazon.smithy.model.loader.ModelAssembler disableValidation()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Disables additional validation of the model.
  ///@return Returns the assembler.
  ModelAssembler disableValidation() {
    return const $ModelAssemblerType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_disableValidation,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_validationEventListener = jniAccessors.getMethodIDOf(
      _classRef,
      r"validationEventListener",
      r"(Ljava/util/function/Consumer;)Lsoftware/amazon/smithy/model/loader/ModelAssembler;");

  /// from: public software.amazon.smithy.model.loader.ModelAssembler validationEventListener(java.util.function.Consumer<software.amazon.smithy.model.validation.ValidationEvent> eventListener)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets a listener that is invoked each time a ValidationEvent is encountered
  /// while loading and validating the model.
  ///
  /// The consumer could be invoked simultaneously by multiple threads. It's
  /// up to the consumer to perform any necessary synchronization. Providing
  /// an event listener is useful for things like CLIs so that events can
  /// be streamed to stdout as soon as they are encountered, rather than
  /// waiting until the entire model is parsed and validated.
  ///@param eventListener Listener invoked for each ValidationEvent.
  ///@return Returns the assembler.
  ModelAssembler validationEventListener(
    jni.JObject eventListener,
  ) {
    return const $ModelAssemblerType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_validationEventListener,
        jni.JniCallType.objectType,
        [eventListener.reference]).object);
  }

  static final _id_assemble = jniAccessors.getMethodIDOf(_classRef, r"assemble",
      r"()Lsoftware/amazon/smithy/model/validation/ValidatedResult;");

  /// from: public software.amazon.smithy.model.validation.ValidatedResult<software.amazon.smithy.model.Model> assemble()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Assembles the model and returns the validated result.
  ///@return Returns the validated result that optionally contains a Model
  ///  and validation events.
  ValidatedResult<Model> assemble() {
    return const $ValidatedResultType($ModelType()).fromRef(jniAccessors
        .callMethodWithArgs(
            reference, _id_assemble, jni.JniCallType.objectType, []).object);
  }
}

class $ModelAssemblerType extends jni.JObjType<ModelAssembler> {
  const $ModelAssemblerType();

  @override
  String get signature =>
      r"Lsoftware/amazon/smithy/model/loader/ModelAssembler;";

  @override
  ModelAssembler fromRef(jni.JObjectPtr ref) => ModelAssembler.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ModelAssemblerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == $ModelAssemblerType &&
        other is $ModelAssemblerType;
  }
}

/// from: software.amazon.smithy.model.node.Node
///
/// Base class of for all Smithy model nodes.
///
/// When loading a Smithy model the data is loaded from the source model
/// file into a tree of nodes. These nodes represent the unvalidated
/// structure of the model document.
class Node extends jni.JObject {
  @override
  late final jni.JObjType $type = type;

  Node.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _classRef =
      jniAccessors.getClassOf(r"software/amazon/smithy/model/node/Node");

  /// The type which includes information such as the signature of this class.
  static const type = $NodeType();
  static final _id_parse = jniAccessors.getStaticMethodIDOf(_classRef, r"parse",
      r"(Ljava/lang/String;)Lsoftware/amazon/smithy/model/node/Node;");

  /// from: static public software.amazon.smithy.model.node.Node parse(java.lang.String json)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Attempts to parse the given JSON string and return a Node.
  ///@param json JSON text to parse.
  ///@return Returns the parsed Node on success.
  ///@throws ModelSyntaxException if the JSON text is invalid.
  static Node parse(
    jni.JString json,
  ) {
    return const $NodeType().fromRef(jniAccessors.callStaticMethodWithArgs(
        _classRef,
        _id_parse,
        jni.JniCallType.objectType,
        [json.reference]).object);
  }

  static final _id_parse1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      r"parse",
      r"(Ljava/lang/String;Ljava/lang/String;)Lsoftware/amazon/smithy/model/node/Node;");

  /// from: static public software.amazon.smithy.model.node.Node parse(java.lang.String json, java.lang.String file)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Attempts to parse the given JSON string and File Name and return a Node.
  ///@param json JSON text to parse.
  ///@param file Filename corresponding to json text
  ///@return Returns the parsed Node on success.
  ///@throws ModelSyntaxException if the JSON text is invalid.
  static Node parse1(
    jni.JString json,
    jni.JString file,
  ) {
    return const $NodeType().fromRef(jniAccessors.callStaticMethodWithArgs(
        _classRef,
        _id_parse1,
        jni.JniCallType.objectType,
        [json.reference, file.reference]).object);
  }

  static final _id_parse2 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      r"parse",
      r"(Ljava/io/InputStream;)Lsoftware/amazon/smithy/model/node/Node;");

  /// from: static public software.amazon.smithy.model.node.Node parse(java.io.InputStream json)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Attempts to parse the given JSON input stream and returns a Node.
  ///@param json JSON input stream to parse. The input stream is closed
  ///   automatically when the content is fully parsed.
  ///@return Returns the parsed Node on success.
  ///@throws ModelSyntaxException if the JSON text is invalid.
  static Node parse2(
    jni.JObject json,
  ) {
    return const $NodeType().fromRef(jniAccessors.callStaticMethodWithArgs(
        _classRef,
        _id_parse2,
        jni.JniCallType.objectType,
        [json.reference]).object);
  }

  static final _id_parse3 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      r"parse",
      r"(Ljava/io/InputStream;Ljava/lang/String;)Lsoftware/amazon/smithy/model/node/Node;");

  /// from: static public software.amazon.smithy.model.node.Node parse(java.io.InputStream json, java.lang.String file)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Attempts to parse the given JSON input stream and returns a Node.
  ///@param json JSON input stream to parse. The input stream is closed
  ///   automatically when the content is fully parsed.
  ///@param file Filename corresponding to json text
  ///@return Returns the parsed Node on success.
  ///@throws ModelSyntaxException if the JSON text is invalid.
  static Node parse3(
    jni.JObject json,
    jni.JString file,
  ) {
    return const $NodeType().fromRef(jniAccessors.callStaticMethodWithArgs(
        _classRef,
        _id_parse3,
        jni.JniCallType.objectType,
        [json.reference, file.reference]).object);
  }

  static final _id_parseJsonWithComments = jniAccessors.getStaticMethodIDOf(
      _classRef,
      r"parseJsonWithComments",
      r"(Ljava/lang/String;Ljava/lang/String;)Lsoftware/amazon/smithy/model/node/Node;");

  /// from: static public software.amazon.smithy.model.node.Node parseJsonWithComments(java.lang.String json, java.lang.String file)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Attempts to parse the given JSON string and File Name and return a Node.
  ///
  /// This parser allows for comments in the JSON.
  ///@param json JSON text to parse.
  ///@param file Filename corresponding to json text
  ///@return Returns the parsed Node on success.
  ///@throws ModelSyntaxException if the JSON text is invalid.
  static Node parseJsonWithComments(
    jni.JString json,
    jni.JString file,
  ) {
    return const $NodeType().fromRef(jniAccessors.callStaticMethodWithArgs(
        _classRef,
        _id_parseJsonWithComments,
        jni.JniCallType.objectType,
        [json.reference, file.reference]).object);
  }

  static final _id_parseJsonWithComments1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      r"parseJsonWithComments",
      r"(Ljava/lang/String;)Lsoftware/amazon/smithy/model/node/Node;");

  /// from: static public software.amazon.smithy.model.node.Node parseJsonWithComments(java.lang.String json)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Attempts to parse the given JSON string and return a Node.
  ///
  /// This parser allows for comments in the JSON.
  ///@param json JSON text to parse.
  ///@return Returns the parsed Node on success.
  ///@throws ModelSyntaxException if the JSON text is invalid.
  static Node parseJsonWithComments1(
    jni.JString json,
  ) {
    return const $NodeType().fromRef(jniAccessors.callStaticMethodWithArgs(
        _classRef,
        _id_parseJsonWithComments1,
        jni.JniCallType.objectType,
        [json.reference]).object);
  }

  static final _id_prettyPrintJson = jniAccessors.getStaticMethodIDOf(
      _classRef,
      r"prettyPrintJson",
      r"(Lsoftware/amazon/smithy/model/node/Node;)Ljava/lang/String;");

  /// from: static public java.lang.String prettyPrintJson(software.amazon.smithy.model.node.Node node)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Writes the contents of a Node to a pretty-printed JSON string.
  ///@param node Node to write.
  ///@return Returns the serialized Node.
  static jni.JString prettyPrintJson(
    Node node,
  ) {
    return const jni.JStringType().fromRef(jniAccessors
        .callStaticMethodWithArgs(_classRef, _id_prettyPrintJson,
            jni.JniCallType.objectType, [node.reference]).object);
  }

  static final _id_prettyPrintJson1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      r"prettyPrintJson",
      r"(Lsoftware/amazon/smithy/model/node/Node;Ljava/lang/String;)Ljava/lang/String;");

  /// from: static public java.lang.String prettyPrintJson(software.amazon.smithy.model.node.Node node, java.lang.String indentString)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Writes the contents of a Node to a pretty-printed JSON string.
  ///@param node Node to write.
  ///@param indentString String to use for indention.
  ///@return Returns the serialized Node.
  static jni.JString prettyPrintJson1(
    Node node,
    jni.JString indentString,
  ) {
    return const jni.JStringType().fromRef(jniAccessors
        .callStaticMethodWithArgs(
            _classRef,
            _id_prettyPrintJson1,
            jni.JniCallType.objectType,
            [node.reference, indentString.reference]).object);
  }

  static final _id_printJson = jniAccessors.getStaticMethodIDOf(
      _classRef,
      r"printJson",
      r"(Lsoftware/amazon/smithy/model/node/Node;)Ljava/lang/String;");

  /// from: static public java.lang.String printJson(software.amazon.smithy.model.node.Node node)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Writes the contents of a Node to a non-pretty-printed JSON string.
  ///@param node Node to write.
  ///@return Returns the serialized Node.
  static jni.JString printJson(
    Node node,
  ) {
    return const jni.JStringType().fromRef(jniAccessors
        .callStaticMethodWithArgs(_classRef, _id_printJson,
            jni.JniCallType.objectType, [node.reference]).object);
  }

  static final _id_from = jniAccessors.getStaticMethodIDOf(_classRef, r"from",
      r"(Ljava/lang/String;)Lsoftware/amazon/smithy/model/node/StringNode;");

  /// from: static public software.amazon.smithy.model.node.StringNode from(java.lang.String value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a StringNode from a String value.
  ///@param value Value to create a node from.
  ///@return Returns the created StringNode.
  static jni.JObject from(
    jni.JString value,
  ) {
    return const jni.JObjectType().fromRef(jniAccessors
        .callStaticMethodWithArgs(_classRef, _id_from,
            jni.JniCallType.objectType, [value.reference]).object);
  }

  static final _id_from1 = jniAccessors.getStaticMethodIDOf(_classRef, r"from",
      r"(Ljava/lang/Number;)Lsoftware/amazon/smithy/model/node/NumberNode;");

  /// from: static public software.amazon.smithy.model.node.NumberNode from(java.lang.Number number)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a NumberNode from a Number value.
  ///@param number Value to create a node from.
  ///@return Returns the created NumberNode.
  static jni.JObject from1(
    jni.JObject number,
  ) {
    return const jni.JObjectType().fromRef(jniAccessors
        .callStaticMethodWithArgs(_classRef, _id_from1,
            jni.JniCallType.objectType, [number.reference]).object);
  }

  static final _id_from2 = jniAccessors.getStaticMethodIDOf(_classRef, r"from",
      r"(Z)Lsoftware/amazon/smithy/model/node/BooleanNode;");

  /// from: static public software.amazon.smithy.model.node.BooleanNode from(boolean value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a BooleanNode from a boolean value.
  ///@param value Value to create a node from.
  ///@return Returns the created BooleanNode.
  static jni.JObject from2(
    bool value,
  ) {
    return const jni.JObjectType().fromRef(jniAccessors
        .callStaticMethodWithArgs(_classRef, _id_from2,
            jni.JniCallType.objectType, [value ? 1 : 0]).object);
  }

  static final _id_from3 = jniAccessors.getStaticMethodIDOf(_classRef, r"from",
      r"(Lsoftware/amazon/smithy/model/node/ToNode;)Lsoftware/amazon/smithy/model/node/Node;");

  /// from: static public software.amazon.smithy.model.node.Node from(software.amazon.smithy.model.node.ToNode value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a Node from a potentially null ToNode value.
  ///@param value Value to create a node from.
  ///@return Returns the created Node.
  static Node from3(
    jni.JObject value,
  ) {
    return const $NodeType().fromRef(jniAccessors.callStaticMethodWithArgs(
        _classRef,
        _id_from3,
        jni.JniCallType.objectType,
        [value.reference]).object);
  }

  static final _id_fromNodes = jniAccessors.getStaticMethodIDOf(
      _classRef,
      r"fromNodes",
      r"(Ljava/util/List;)Lsoftware/amazon/smithy/model/node/ArrayNode;");

  /// from: static public software.amazon.smithy.model.node.ArrayNode fromNodes(java.util.List<? extends software.amazon.smithy.model.node.Node> values)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates an ArrayNode from a Collection of Node values.
  ///@param values String values to add to the ArrayNode.
  ///@return Returns the created ArrayNode.
  static jni.JObject fromNodes(
    jni.JObject values,
  ) {
    return const jni.JObjectType().fromRef(jniAccessors
        .callStaticMethodWithArgs(_classRef, _id_fromNodes,
            jni.JniCallType.objectType, [values.reference]).object);
  }

  static final _id_fromNodes1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      r"fromNodes",
      r"([Lsoftware/amazon/smithy/model/node/Node;)Lsoftware/amazon/smithy/model/node/ArrayNode;");

  /// from: static public software.amazon.smithy.model.node.ArrayNode fromNodes(software.amazon.smithy.model.node.Node[] values)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates an ArrayNode from a variadic list of Node values.
  ///@param values String values to add to the ArrayNode.
  ///@return Returns the created ArrayNode.
  static jni.JObject fromNodes1(
    jni.JArray<Node> values,
  ) {
    return const jni.JObjectType().fromRef(jniAccessors
        .callStaticMethodWithArgs(_classRef, _id_fromNodes1,
            jni.JniCallType.objectType, [values.reference]).object);
  }

  static final _id_fromStrings = jniAccessors.getStaticMethodIDOf(
      _classRef,
      r"fromStrings",
      r"(Ljava/util/Collection;)Lsoftware/amazon/smithy/model/node/ArrayNode;");

  /// from: static public software.amazon.smithy.model.node.ArrayNode fromStrings(java.util.Collection<java.lang.String> values)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates an ArrayNode from a Collection of String values.
  ///@param values String values to add to the ArrayNode.
  ///@return Returns the created ArrayNode.
  static jni.JObject fromStrings(
    jni.JObject values,
  ) {
    return const jni.JObjectType().fromRef(jniAccessors
        .callStaticMethodWithArgs(_classRef, _id_fromStrings,
            jni.JniCallType.objectType, [values.reference]).object);
  }

  static final _id_fromStrings1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      r"fromStrings",
      r"([Ljava/lang/String;)Lsoftware/amazon/smithy/model/node/ArrayNode;");

  /// from: static public software.amazon.smithy.model.node.ArrayNode fromStrings(java.lang.String[] values)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates an ArrayNode from a variadic list of String values.
  ///@param values String values to add to the ArrayNode.
  ///@return Returns the created ArrayNode.
  static jni.JObject fromStrings1(
    jni.JArray<jni.JString> values,
  ) {
    return const jni.JObjectType().fromRef(jniAccessors
        .callStaticMethodWithArgs(_classRef, _id_fromStrings1,
            jni.JniCallType.objectType, [values.reference]).object);
  }

  static final _id_objectNodeBuilder = jniAccessors.getStaticMethodIDOf(
      _classRef,
      r"objectNodeBuilder",
      r"()Lsoftware/amazon/smithy/model/node/ObjectNode$Builder;");

  /// from: static public software.amazon.smithy.model.node.ObjectNode.Builder objectNodeBuilder()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates an ObjectNode.Builder.
  ///@return Returns the ObjectNode builder.
  static jni.JObject objectNodeBuilder() {
    return const jni.JObjectType().fromRef(jniAccessors
        .callStaticMethodWithArgs(_classRef, _id_objectNodeBuilder,
            jni.JniCallType.objectType, []).object);
  }

  static final _id_objectNode = jniAccessors.getStaticMethodIDOf(_classRef,
      r"objectNode", r"()Lsoftware/amazon/smithy/model/node/ObjectNode;");

  /// from: static public software.amazon.smithy.model.node.ObjectNode objectNode()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates an empty ObjectNode.
  ///@return Returns the ObjectNode.
  static jni.JObject objectNode() {
    return const jni.JObjectType().fromRef(jniAccessors
        .callStaticMethodWithArgs(
            _classRef, _id_objectNode, jni.JniCallType.objectType, []).object);
  }

  static final _id_objectNode1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      r"objectNode",
      r"(Ljava/util/Map;)Lsoftware/amazon/smithy/model/node/ObjectNode;");

  /// from: static public software.amazon.smithy.model.node.ObjectNode objectNode(java.util.Map<software.amazon.smithy.model.node.StringNode,software.amazon.smithy.model.node.Node> values)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates an ObjectNode from the given map of Nodes.
  ///@param values Values to add to the object node.
  ///@return Returns the created ObjectNode.
  static jni.JObject objectNode1(
    jni.JObject values,
  ) {
    return const jni.JObjectType().fromRef(jniAccessors
        .callStaticMethodWithArgs(_classRef, _id_objectNode1,
            jni.JniCallType.objectType, [values.reference]).object);
  }

  static final _id_arrayNode = jniAccessors.getStaticMethodIDOf(_classRef,
      r"arrayNode", r"()Lsoftware/amazon/smithy/model/node/ArrayNode;");

  /// from: static public software.amazon.smithy.model.node.ArrayNode arrayNode()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates an empty ArrayNode.
  ///@return Returns the ArrayNode.
  static jni.JObject arrayNode() {
    return const jni.JObjectType().fromRef(jniAccessors
        .callStaticMethodWithArgs(
            _classRef, _id_arrayNode, jni.JniCallType.objectType, []).object);
  }

  static final _id_arrayNode1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      r"arrayNode",
      r"([Lsoftware/amazon/smithy/model/node/Node;)Lsoftware/amazon/smithy/model/node/ArrayNode;");

  /// from: static public software.amazon.smithy.model.node.ArrayNode arrayNode(software.amazon.smithy.model.node.Node[] nodes)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates an ArrayNode from a variadic list of Nodes.
  ///@param nodes Nodes to add to the array.
  ///@return Returns the created ArrayNode.
  static jni.JObject arrayNode1(
    jni.JArray<Node> nodes,
  ) {
    return const jni.JObjectType().fromRef(jniAccessors
        .callStaticMethodWithArgs(_classRef, _id_arrayNode1,
            jni.JniCallType.objectType, [nodes.reference]).object);
  }

  static final _id_nullNode = jniAccessors.getStaticMethodIDOf(_classRef,
      r"nullNode", r"()Lsoftware/amazon/smithy/model/node/NullNode;");

  /// from: static public software.amazon.smithy.model.node.NullNode nullNode()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a NullNode.
  ///@return Returns the NullNode.
  static jni.JObject nullNode() {
    return const jni.JObjectType().fromRef(jniAccessors
        .callStaticMethodWithArgs(
            _classRef, _id_nullNode, jni.JniCallType.objectType, []).object);
  }

  static final _id_loadArrayOfString = jniAccessors.getStaticMethodIDOf(
      _classRef,
      r"loadArrayOfString",
      r"(Ljava/lang/String;Lsoftware/amazon/smithy/model/node/Node;)Ljava/util/List;");

  /// from: static public java.util.List<java.lang.String> loadArrayOfString(java.lang.String descriptor, software.amazon.smithy.model.node.Node node)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Expects an array of strings and returns the loaded strings.
  ///@param descriptor Name of the property being loaded.
  ///@param node Node to load.
  ///@return Returns the loaded strings.
  ///@throws SourceException on error.
  static jni.JObject loadArrayOfString(
    jni.JString descriptor,
    Node node,
  ) {
    return const jni.JObjectType().fromRef(jniAccessors
        .callStaticMethodWithArgs(
            _classRef,
            _id_loadArrayOfString,
            jni.JniCallType.objectType,
            [descriptor.reference, node.reference]).object);
  }

  static final _id_assertEquals = jniAccessors.getStaticMethodIDOf(
      _classRef,
      r"assertEquals",
      r"(Lsoftware/amazon/smithy/model/node/ToNode;Lsoftware/amazon/smithy/model/node/ToNode;)V");

  /// from: static public void assertEquals(software.amazon.smithy.model.node.ToNode actual, software.amazon.smithy.model.node.ToNode expected)
  ///
  /// Testing helper used to compare two Nodes for equivalence.
  ///
  /// Compares two Node values and throws if they aren't equal. The
  /// thrown exception contains a message that shows the differences
  /// between the two Nodes as returned by \#diff(ToNode, ToNode).
  ///@param actual Node to use as the starting node.
  ///@param expected Node to compare against.
  ///@throws ExpectationNotMetException if the nodes are not equivalent.
  static void assertEquals(
    jni.JObject actual,
    jni.JObject expected,
  ) {
    return jniAccessors.callStaticMethodWithArgs(
        _classRef,
        _id_assertEquals,
        jni.JniCallType.voidType,
        [actual.reference, expected.reference]).check();
  }

  static final _id_diff = jniAccessors.getStaticMethodIDOf(_classRef, r"diff",
      r"(Lsoftware/amazon/smithy/model/node/ToNode;Lsoftware/amazon/smithy/model/node/ToNode;)Ljava/util/List;");

  /// from: static public java.util.List<java.lang.String> diff(software.amazon.smithy.model.node.ToNode actual, software.amazon.smithy.model.node.ToNode expected)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Computes the differences between two Nodes as a String.
  ///@param actual Node to use as the starting node.
  ///@param expected Node to compare against.
  ///@return Returns the differences as a String.
  static jni.JObject diff(
    jni.JObject actual,
    jni.JObject expected,
  ) {
    return const jni.JObjectType().fromRef(jniAccessors
        .callStaticMethodWithArgs(
            _classRef,
            _id_diff,
            jni.JniCallType.objectType,
            [actual.reference, expected.reference]).object);
  }

  static final _id_getType = jniAccessors.getMethodIDOf(
      _classRef, r"getType", r"()Lsoftware/amazon/smithy/model/node/NodeType;");

  /// from: public abstract software.amazon.smithy.model.node.NodeType getType()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the type of the node.
  ///@return Returns the node type.
  jni.JObject getType() {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference, _id_getType, jni.JniCallType.objectType, []).object);
  }

  static final _id_accept = jniAccessors.getMethodIDOf(_classRef, r"accept",
      r"(Lsoftware/amazon/smithy/model/node/NodeVisitor;)Ljava/lang/Object;");

  /// from: public abstract R accept(software.amazon.smithy.model.node.NodeVisitor<R> visitor)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Accepts a visitor with the node.
  ///@param visitor Visitor to dispatch to.
  ///@param <R> visitor return type.
  ///@return Returns the accepted result.
  $R accept<$R extends jni.JObject>(
    jni.JObject visitor, {
    required jni.JObjType<$R> R,
  }) {
    return R.fromRef(jniAccessors.callMethodWithArgs(reference, _id_accept,
        jni.JniCallType.objectType, [visitor.reference]).object);
  }

  static final _id_isObjectNode =
      jniAccessors.getMethodIDOf(_classRef, r"isObjectNode", r"()Z");

  /// from: public final boolean isObjectNode()
  ///
  /// Checks if this node is an object type.
  ///@return Returns true if this node is an object type.
  bool isObjectNode() {
    return jniAccessors.callMethodWithArgs(
        reference, _id_isObjectNode, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_isArrayNode =
      jniAccessors.getMethodIDOf(_classRef, r"isArrayNode", r"()Z");

  /// from: public final boolean isArrayNode()
  ///
  /// Checks if this node is an array type.
  ///@return Returns true if this node is an array type.
  bool isArrayNode() {
    return jniAccessors.callMethodWithArgs(
        reference, _id_isArrayNode, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_isStringNode =
      jniAccessors.getMethodIDOf(_classRef, r"isStringNode", r"()Z");

  /// from: public final boolean isStringNode()
  ///
  /// Checks if this node is a string type.
  ///@return Returns true if this node is a string type.
  bool isStringNode() {
    return jniAccessors.callMethodWithArgs(
        reference, _id_isStringNode, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_isNumberNode =
      jniAccessors.getMethodIDOf(_classRef, r"isNumberNode", r"()Z");

  /// from: public final boolean isNumberNode()
  ///
  /// Checks if this node is a number type.
  ///@return Returns true if this node is a number type.
  bool isNumberNode() {
    return jniAccessors.callMethodWithArgs(
        reference, _id_isNumberNode, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_isBooleanNode =
      jniAccessors.getMethodIDOf(_classRef, r"isBooleanNode", r"()Z");

  /// from: public final boolean isBooleanNode()
  ///
  /// Checks if this node is a boolean type.
  ///@return Returns true if this node is a boolean type.
  bool isBooleanNode() {
    return jniAccessors.callMethodWithArgs(
        reference, _id_isBooleanNode, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_isNullNode =
      jniAccessors.getMethodIDOf(_classRef, r"isNullNode", r"()Z");

  /// from: public final boolean isNullNode()
  ///
  /// Checks if this node is a null type.
  ///@return Returns true if this node is a null type.
  bool isNullNode() {
    return jniAccessors.callMethodWithArgs(
        reference, _id_isNullNode, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_asObjectNode = jniAccessors.getMethodIDOf(
      _classRef, r"asObjectNode", r"()Ljava/util/Optional;");

  /// from: public java.util.Optional<software.amazon.smithy.model.node.ObjectNode> asObjectNode()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the node as an ObjectNode if it is an object.
  ///@return Returns the optional object node.
  jni.JObject asObjectNode() {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference, _id_asObjectNode, jni.JniCallType.objectType, []).object);
  }

  static final _id_asArrayNode = jniAccessors.getMethodIDOf(
      _classRef, r"asArrayNode", r"()Ljava/util/Optional;");

  /// from: public java.util.Optional<software.amazon.smithy.model.node.ArrayNode> asArrayNode()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the node as an ArrayNode if it is an array.
  ///@return Returns the optional array node.
  jni.JObject asArrayNode() {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference, _id_asArrayNode, jni.JniCallType.objectType, []).object);
  }

  static final _id_asStringNode = jniAccessors.getMethodIDOf(
      _classRef, r"asStringNode", r"()Ljava/util/Optional;");

  /// from: public java.util.Optional<software.amazon.smithy.model.node.StringNode> asStringNode()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the node as an StringNode if it is an string.
  ///@return Returns the optional StringNode.
  jni.JObject asStringNode() {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference, _id_asStringNode, jni.JniCallType.objectType, []).object);
  }

  static final _id_asBooleanNode = jniAccessors.getMethodIDOf(
      _classRef, r"asBooleanNode", r"()Ljava/util/Optional;");

  /// from: public java.util.Optional<software.amazon.smithy.model.node.BooleanNode> asBooleanNode()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the node as an BooleanNode if it is an boolean.
  ///@return Returns the optional BooleanNode.
  jni.JObject asBooleanNode() {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference, _id_asBooleanNode, jni.JniCallType.objectType, []).object);
  }

  static final _id_asNumberNode = jniAccessors.getMethodIDOf(
      _classRef, r"asNumberNode", r"()Ljava/util/Optional;");

  /// from: public java.util.Optional<software.amazon.smithy.model.node.NumberNode> asNumberNode()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the node as an NumberNode if it is an number.
  ///@return Returns the optional NumberNode.
  jni.JObject asNumberNode() {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference, _id_asNumberNode, jni.JniCallType.objectType, []).object);
  }

  static final _id_asNullNode = jniAccessors.getMethodIDOf(
      _classRef, r"asNullNode", r"()Ljava/util/Optional;");

  /// from: public java.util.Optional<software.amazon.smithy.model.node.NullNode> asNullNode()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the node as an NullNode if it is a null.
  ///@return Returns the optional NullNode.
  jni.JObject asNullNode() {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference, _id_asNullNode, jni.JniCallType.objectType, []).object);
  }

  static final _id_expectObjectNode = jniAccessors.getMethodIDOf(_classRef,
      r"expectObjectNode", r"()Lsoftware/amazon/smithy/model/node/ObjectNode;");

  /// from: public final software.amazon.smithy.model.node.ObjectNode expectObjectNode()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Casts the current node to an {@code ObjectNode}.
  ///@return Returns an object node.
  ///@throws ExpectationNotMetException when the node is not an {@code ObjectNode}.
  jni.JObject expectObjectNode() {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_expectObjectNode,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_expectObjectNode1 = jniAccessors.getMethodIDOf(
      _classRef,
      r"expectObjectNode",
      r"(Ljava/lang/String;)Lsoftware/amazon/smithy/model/node/ObjectNode;");

  /// from: public software.amazon.smithy.model.node.ObjectNode expectObjectNode(java.lang.String message)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Casts the current node to an {@code ObjectNode}, throwing
  /// ExpectationNotMetException when the node is the wrong type.
  ///@param message Error message to use if the node is of the wrong type.
  ///@return Returns an object node.
  ///@throws ExpectationNotMetException when the node is not an {@code ObjectNode}.
  jni.JObject expectObjectNode1(
    jni.JString message,
  ) {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_expectObjectNode1,
        jni.JniCallType.objectType,
        [message.reference]).object);
  }

  static final _id_expectObjectNode2 = jniAccessors.getMethodIDOf(
      _classRef,
      r"expectObjectNode",
      r"(Ljava/util/function/Supplier;)Lsoftware/amazon/smithy/model/node/ObjectNode;");

  /// from: public software.amazon.smithy.model.node.ObjectNode expectObjectNode(java.util.function.Supplier<java.lang.String> message)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Casts the current node to an {@code ObjectNode}, throwing
  /// ExpectationNotMetException when the node is the wrong type.
  ///@param message Error message supplier.
  ///@return Returns an object node.
  ///@throws ExpectationNotMetException when the node is not an {@code ObjectNode}.
  jni.JObject expectObjectNode2(
    jni.JObject message,
  ) {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_expectObjectNode2,
        jni.JniCallType.objectType,
        [message.reference]).object);
  }

  static final _id_expectArrayNode = jniAccessors.getMethodIDOf(_classRef,
      r"expectArrayNode", r"()Lsoftware/amazon/smithy/model/node/ArrayNode;");

  /// from: public final software.amazon.smithy.model.node.ArrayNode expectArrayNode()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Casts the current node to an {@code ArrayNode}.
  ///@return Returns an array node.
  ///@throws ExpectationNotMetException when the node is not an {@code ArrayNode}.
  jni.JObject expectArrayNode() {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference, _id_expectArrayNode, jni.JniCallType.objectType, []).object);
  }

  static final _id_expectArrayNode1 = jniAccessors.getMethodIDOf(
      _classRef,
      r"expectArrayNode",
      r"(Ljava/lang/String;)Lsoftware/amazon/smithy/model/node/ArrayNode;");

  /// from: public software.amazon.smithy.model.node.ArrayNode expectArrayNode(java.lang.String message)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Casts the current node to an {@code ArrayNode}, throwing
  /// ExpectationNotMetException when the node is the wrong type.
  ///@param message Error message to use if the node is of the wrong type.
  ///@return Returns an array node.
  ///@throws ExpectationNotMetException when the node is the wrong type.
  jni.JObject expectArrayNode1(
    jni.JString message,
  ) {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_expectArrayNode1,
        jni.JniCallType.objectType,
        [message.reference]).object);
  }

  static final _id_expectArrayNode2 = jniAccessors.getMethodIDOf(
      _classRef,
      r"expectArrayNode",
      r"(Ljava/util/function/Supplier;)Lsoftware/amazon/smithy/model/node/ArrayNode;");

  /// from: public software.amazon.smithy.model.node.ArrayNode expectArrayNode(java.util.function.Supplier<java.lang.String> message)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Casts the current node to an {@code ArrayNode}, throwing
  /// ExpectationNotMetException when the node is the wrong type.
  ///@param message Error message supplier.
  ///@return Returns an array node.
  ///@throws ExpectationNotMetException when the node is the wrong type.
  jni.JObject expectArrayNode2(
    jni.JObject message,
  ) {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_expectArrayNode2,
        jni.JniCallType.objectType,
        [message.reference]).object);
  }

  static final _id_expectStringNode = jniAccessors.getMethodIDOf(_classRef,
      r"expectStringNode", r"()Lsoftware/amazon/smithy/model/node/StringNode;");

  /// from: public final software.amazon.smithy.model.node.StringNode expectStringNode()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Casts the current node to a {@code StringNode}.
  ///@return Returns a string node.
  ///@throws ExpectationNotMetException when the node is the wrong type.
  jni.JObject expectStringNode() {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_expectStringNode,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_expectStringNode1 = jniAccessors.getMethodIDOf(
      _classRef,
      r"expectStringNode",
      r"(Ljava/lang/String;)Lsoftware/amazon/smithy/model/node/StringNode;");

  /// from: public software.amazon.smithy.model.node.StringNode expectStringNode(java.lang.String message)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Casts the current node to a {@code StringNode}, throwing
  /// ExpectationNotMetException when the node is the wrong type.
  ///@param message Error message to use if the node is of the wrong type.
  ///@return Returns a string node.
  ///@throws ExpectationNotMetException when the node is the wrong type.
  jni.JObject expectStringNode1(
    jni.JString message,
  ) {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_expectStringNode1,
        jni.JniCallType.objectType,
        [message.reference]).object);
  }

  static final _id_expectStringNode2 = jniAccessors.getMethodIDOf(
      _classRef,
      r"expectStringNode",
      r"(Ljava/util/function/Supplier;)Lsoftware/amazon/smithy/model/node/StringNode;");

  /// from: public software.amazon.smithy.model.node.StringNode expectStringNode(java.util.function.Supplier<java.lang.String> message)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Casts the current node to a {@code StringNode}, throwing
  /// ExpectationNotMetException when the node is the wrong type.
  ///@param message Error message supplier.
  ///@return Returns a string node.
  ///@throws ExpectationNotMetException when the node is the wrong type.
  jni.JObject expectStringNode2(
    jni.JObject message,
  ) {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_expectStringNode2,
        jni.JniCallType.objectType,
        [message.reference]).object);
  }

  static final _id_expectNumberNode = jniAccessors.getMethodIDOf(_classRef,
      r"expectNumberNode", r"()Lsoftware/amazon/smithy/model/node/NumberNode;");

  /// from: public final software.amazon.smithy.model.node.NumberNode expectNumberNode()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Casts the current node to a {@code NumberNode}.
  ///@return Returns a number node.
  ///@throws ExpectationNotMetException when the node is the wrong type.
  jni.JObject expectNumberNode() {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_expectNumberNode,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_expectNumberNode1 = jniAccessors.getMethodIDOf(
      _classRef,
      r"expectNumberNode",
      r"(Ljava/lang/String;)Lsoftware/amazon/smithy/model/node/NumberNode;");

  /// from: public software.amazon.smithy.model.node.NumberNode expectNumberNode(java.lang.String message)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Casts the current node to a {@code NumberNode}, throwing
  /// ExpectationNotMetException when the node is the wrong type.
  ///@param message Error message to use if the node is of the wrong type.
  ///@return Returns a number node.
  ///@throws ExpectationNotMetException when the node is the wrong type.
  jni.JObject expectNumberNode1(
    jni.JString message,
  ) {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_expectNumberNode1,
        jni.JniCallType.objectType,
        [message.reference]).object);
  }

  static final _id_expectNumberNode2 = jniAccessors.getMethodIDOf(
      _classRef,
      r"expectNumberNode",
      r"(Ljava/util/function/Supplier;)Lsoftware/amazon/smithy/model/node/NumberNode;");

  /// from: public software.amazon.smithy.model.node.NumberNode expectNumberNode(java.util.function.Supplier<java.lang.String> message)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Casts the current node to a {@code NumberNode}, throwing
  /// ExpectationNotMetException when the node is the wrong type.
  ///@param message Error message supplier.
  ///@return Returns a number node.
  ///@throws ExpectationNotMetException when the node is the wrong type.
  jni.JObject expectNumberNode2(
    jni.JObject message,
  ) {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_expectNumberNode2,
        jni.JniCallType.objectType,
        [message.reference]).object);
  }

  static final _id_expectBooleanNode = jniAccessors.getMethodIDOf(
      _classRef,
      r"expectBooleanNode",
      r"()Lsoftware/amazon/smithy/model/node/BooleanNode;");

  /// from: public final software.amazon.smithy.model.node.BooleanNode expectBooleanNode()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Casts the current node to a {@code BooleanNode}.
  ///@return Returns a boolean node.
  ///@throws ExpectationNotMetException when the node is the wrong type.
  jni.JObject expectBooleanNode() {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_expectBooleanNode,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_expectBooleanNode1 = jniAccessors.getMethodIDOf(
      _classRef,
      r"expectBooleanNode",
      r"(Ljava/lang/String;)Lsoftware/amazon/smithy/model/node/BooleanNode;");

  /// from: public software.amazon.smithy.model.node.BooleanNode expectBooleanNode(java.lang.String message)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Casts the current node to a {@code BooleanNode}, throwing
  /// ExpectationNotMetException when the node is the wrong type.
  ///@param message Error message to use if the node is of the wrong type.
  ///@return Returns a boolean node.
  ///@throws ExpectationNotMetException when the node is the wrong type.
  jni.JObject expectBooleanNode1(
    jni.JString message,
  ) {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_expectBooleanNode1,
        jni.JniCallType.objectType,
        [message.reference]).object);
  }

  static final _id_expectBooleanNode2 = jniAccessors.getMethodIDOf(
      _classRef,
      r"expectBooleanNode",
      r"(Ljava/util/function/Supplier;)Lsoftware/amazon/smithy/model/node/BooleanNode;");

  /// from: public software.amazon.smithy.model.node.BooleanNode expectBooleanNode(java.util.function.Supplier<java.lang.String> message)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Casts the current node to a {@code BooleanNode}, throwing
  /// ExpectationNotMetException when the node is the wrong type.
  ///@param message Error message supplier.
  ///@return Returns a boolean node.
  ///@throws ExpectationNotMetException when the node is the wrong type.
  jni.JObject expectBooleanNode2(
    jni.JObject message,
  ) {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_expectBooleanNode2,
        jni.JniCallType.objectType,
        [message.reference]).object);
  }

  static final _id_expectNullNode = jniAccessors.getMethodIDOf(_classRef,
      r"expectNullNode", r"()Lsoftware/amazon/smithy/model/node/NullNode;");

  /// from: public final software.amazon.smithy.model.node.NullNode expectNullNode()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Casts the current node to a {@code NullNode}.
  ///@return Returns a null node.
  ///@throws ExpectationNotMetException when the node is the wrong type.
  jni.JObject expectNullNode() {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference, _id_expectNullNode, jni.JniCallType.objectType, []).object);
  }

  static final _id_expectNullNode1 = jniAccessors.getMethodIDOf(
      _classRef,
      r"expectNullNode",
      r"(Ljava/lang/String;)Lsoftware/amazon/smithy/model/node/NullNode;");

  /// from: public software.amazon.smithy.model.node.NullNode expectNullNode(java.lang.String message)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Casts the current node to a {@code NullNode}, throwing
  /// ExpectationNotMetException when the node is the wrong type.
  ///@param message Error message to use if the node is of the wrong type.
  ///@return Returns a null node.
  ///@throws ExpectationNotMetException when the node is the wrong type.
  jni.JObject expectNullNode1(
    jni.JString message,
  ) {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_expectNullNode1,
        jni.JniCallType.objectType,
        [message.reference]).object);
  }

  static final _id_expectNullNode2 = jniAccessors.getMethodIDOf(
      _classRef,
      r"expectNullNode",
      r"(Ljava/util/function/Supplier;)Lsoftware/amazon/smithy/model/node/NullNode;");

  /// from: public software.amazon.smithy.model.node.NullNode expectNullNode(java.util.function.Supplier<java.lang.String> message)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Casts the current node to a {@code NullNode}, throwing
  /// ExpectationNotMetException when the node is the wrong type.
  ///@param message Error message supplier.
  ///@return Returns a null node.
  ///@throws ExpectationNotMetException when the node is the wrong type.
  jni.JObject expectNullNode2(
    jni.JObject message,
  ) {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_expectNullNode2,
        jni.JniCallType.objectType,
        [message.reference]).object);
  }

  static final _id_getSourceLocation = jniAccessors.getMethodIDOf(_classRef,
      r"getSourceLocation", r"()Lsoftware/amazon/smithy/model/SourceLocation;");

  /// from: public final software.amazon.smithy.model.SourceLocation getSourceLocation()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JObject getSourceLocation() {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_getSourceLocation,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_toNode = jniAccessors.getMethodIDOf(
      _classRef, r"toNode", r"()Lsoftware/amazon/smithy/model/node/Node;");

  /// from: public final software.amazon.smithy.model.node.Node toNode()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Node toNode() {
    return const $NodeType().fromRef(jniAccessors.callMethodWithArgs(
        reference, _id_toNode, jni.JniCallType.objectType, []).object);
  }

  static final _id_withDeepSortedKeys = jniAccessors.getMethodIDOf(_classRef,
      r"withDeepSortedKeys", r"()Lsoftware/amazon/smithy/model/node/Node;");

  /// from: public final software.amazon.smithy.model.node.Node withDeepSortedKeys()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a node with sorted keys and sorted keys of all nested object
  /// nodes.
  ///@return Returns the node in which all object nodes have sorted keys.
  Node withDeepSortedKeys() {
    return const $NodeType().fromRef(jniAccessors.callMethodWithArgs(reference,
        _id_withDeepSortedKeys, jni.JniCallType.objectType, []).object);
  }

  static final _id_withDeepSortedKeys1 = jniAccessors.getMethodIDOf(
      _classRef,
      r"withDeepSortedKeys",
      r"(Ljava/util/Comparator;)Lsoftware/amazon/smithy/model/node/Node;");

  /// from: public final software.amazon.smithy.model.node.Node withDeepSortedKeys(java.util.Comparator<software.amazon.smithy.model.node.StringNode> keyComparator)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a node with sorted keys and sorted keys of all nested object
  /// nodes using a custom comparator.
  ///@param keyComparator Compares keys.
  ///@return Returns the node in which all object nodes have sorted keys.
  Node withDeepSortedKeys1(
    jni.JObject keyComparator,
  ) {
    return const $NodeType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_withDeepSortedKeys1,
        jni.JniCallType.objectType,
        [keyComparator.reference]).object);
  }
}

class $NodeType extends jni.JObjType<Node> {
  const $NodeType();

  @override
  String get signature => r"Lsoftware/amazon/smithy/model/node/Node;";

  @override
  Node fromRef(jni.JObjectPtr ref) => Node.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($NodeType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == $NodeType && other is $NodeType;
  }
}

/// from: software.amazon.smithy.model.node.Node$NonNumericFloat
///
/// Non-numeric values for floats and doubles.
class Node_NonNumericFloat extends jni.JObject {
  @override
  late final jni.JObjType $type = type;

  Node_NonNumericFloat.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _classRef = jniAccessors
      .getClassOf(r"software/amazon/smithy/model/node/Node$NonNumericFloat");

  /// The type which includes information such as the signature of this class.
  static const type = $Node_NonNumericFloatType();
  static final _id_values = jniAccessors.getStaticMethodIDOf(
      _classRef,
      r"values",
      r"()[Lsoftware/amazon/smithy/model/node/Node$NonNumericFloat;");

  /// from: static public software.amazon.smithy.model.node.Node.NonNumericFloat[] values()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JArray<Node_NonNumericFloat> values() {
    return const jni.JArrayType($Node_NonNumericFloatType()).fromRef(
        jniAccessors.callStaticMethodWithArgs(
            _classRef, _id_values, jni.JniCallType.objectType, []).object);
  }

  static final _id_valueOf = jniAccessors.getStaticMethodIDOf(
      _classRef,
      r"valueOf",
      r"(Ljava/lang/String;)Lsoftware/amazon/smithy/model/node/Node$NonNumericFloat;");

  /// from: static public software.amazon.smithy.model.node.Node.NonNumericFloat valueOf(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static Node_NonNumericFloat valueOf(
    jni.JString name,
  ) {
    return const $Node_NonNumericFloatType().fromRef(jniAccessors
        .callStaticMethodWithArgs(_classRef, _id_valueOf,
            jni.JniCallType.objectType, [name.reference]).object);
  }

  static final _id_getStringRepresentation = jniAccessors.getMethodIDOf(
      _classRef, r"getStringRepresentation", r"()Ljava/lang/String;");

  /// from: public java.lang.String getStringRepresentation()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return The string representation of this non-numeric float.
  jni.JString getStringRepresentation() {
    return const jni.JStringType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_getStringRepresentation,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_stringRepresentations = jniAccessors.getStaticMethodIDOf(
      _classRef, r"stringRepresentations", r"()Ljava/util/Set;");

  /// from: static public java.util.Set<java.lang.String> stringRepresentations()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return All the possible string representations of non-numeric floats.
  static jni.JObject stringRepresentations() {
    return const jni.JObjectType().fromRef(jniAccessors
        .callStaticMethodWithArgs(_classRef, _id_stringRepresentations,
            jni.JniCallType.objectType, []).object);
  }

  static final _id_fromStringRepresentation = jniAccessors.getStaticMethodIDOf(
      _classRef,
      r"fromStringRepresentation",
      r"(Ljava/lang/String;)Ljava/util/Optional;");

  /// from: static public java.util.Optional<software.amazon.smithy.model.node.Node.NonNumericFloat> fromStringRepresentation(java.lang.String value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Convert a string value into a NonNumericFloat.
  ///@param value A string representation of a non-numeric float value.
  ///@return A NonNumericFloat that represents the given string value or empty if there is no associated value.
  static jni.JObject fromStringRepresentation(
    jni.JString value,
  ) {
    return const jni.JObjectType().fromRef(jniAccessors
        .callStaticMethodWithArgs(_classRef, _id_fromStringRepresentation,
            jni.JniCallType.objectType, [value.reference]).object);
  }
}

class $Node_NonNumericFloatType extends jni.JObjType<Node_NonNumericFloat> {
  const $Node_NonNumericFloatType();

  @override
  String get signature =>
      r"Lsoftware/amazon/smithy/model/node/Node$NonNumericFloat;";

  @override
  Node_NonNumericFloat fromRef(jni.JObjectPtr ref) =>
      Node_NonNumericFloat.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Node_NonNumericFloatType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == $Node_NonNumericFloatType &&
        other is $Node_NonNumericFloatType;
  }
}

/// from: software.amazon.smithy.model.shapes.ModelSerializer
///
/// Serializes a Model to an ObjectNode.
///
/// The serialized value sorts all map key-value pairs so that they contain
/// a consistent key ordering, reducing noise in diffs based on
/// serialized model.
///
/// After serializing to an ObjectNode, the node can then be serialized
/// to formats like JSON, YAML, Ion, etc.
class ModelSerializer extends jni.JObject {
  @override
  late final jni.JObjType $type = type;

  ModelSerializer.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _classRef = jniAccessors
      .getClassOf(r"software/amazon/smithy/model/shapes/ModelSerializer");

  /// The type which includes information such as the signature of this class.
  static const type = $ModelSerializerType();
  static final _id_serialize = jniAccessors.getMethodIDOf(
      _classRef,
      r"serialize",
      r"(Lsoftware/amazon/smithy/model/Model;)Lsoftware/amazon/smithy/model/node/ObjectNode;");

  /// from: public software.amazon.smithy.model.node.ObjectNode serialize(software.amazon.smithy.model.Model model)
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JObject serialize(
    Model model,
  ) {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_serialize,
        jni.JniCallType.objectType,
        [model.reference]).object);
  }

  static final _id_builder = jniAccessors.getStaticMethodIDOf(
      _classRef,
      r"builder",
      r"()Lsoftware/amazon/smithy/model/shapes/ModelSerializer$Builder;");

  /// from: static public software.amazon.smithy.model.shapes.ModelSerializer.Builder builder()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return Returns a builder used to create a ModelSerializer.
  static ModelSerializer_Builder builder() {
    return const $ModelSerializer_BuilderType().fromRef(jniAccessors
        .callStaticMethodWithArgs(
            _classRef, _id_builder, jni.JniCallType.objectType, []).object);
  }
}

class $ModelSerializerType extends jni.JObjType<ModelSerializer> {
  const $ModelSerializerType();

  @override
  String get signature =>
      r"Lsoftware/amazon/smithy/model/shapes/ModelSerializer;";

  @override
  ModelSerializer fromRef(jni.JObjectPtr ref) => ModelSerializer.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ModelSerializerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == $ModelSerializerType &&
        other is $ModelSerializerType;
  }
}

/// from: software.amazon.smithy.model.shapes.ModelSerializer$Builder
///
/// Builder used to create ModelSerializer.
class ModelSerializer_Builder extends jni.JObject {
  @override
  late final jni.JObjType $type = type;

  ModelSerializer_Builder.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _classRef = jniAccessors.getClassOf(
      r"software/amazon/smithy/model/shapes/ModelSerializer$Builder");

  /// The type which includes information such as the signature of this class.
  static const type = $ModelSerializer_BuilderType();
  static final _id_metadataFilter = jniAccessors.getMethodIDOf(
      _classRef,
      r"metadataFilter",
      r"(Ljava/util/function/Predicate;)Lsoftware/amazon/smithy/model/shapes/ModelSerializer$Builder;");

  /// from: public software.amazon.smithy.model.shapes.ModelSerializer.Builder metadataFilter(java.util.function.Predicate<java.lang.String> metadataFilter)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Predicate that determines if a metadata is serialized.
  ///@param metadataFilter Predicate that accepts a metadata key.
  ///@return Returns the builder.
  ModelSerializer_Builder metadataFilter(
    jni.JObject metadataFilter,
  ) {
    return const $ModelSerializer_BuilderType().fromRef(jniAccessors
        .callMethodWithArgs(reference, _id_metadataFilter,
            jni.JniCallType.objectType, [metadataFilter.reference]).object);
  }

  static final _id_shapeFilter = jniAccessors.getMethodIDOf(
      _classRef,
      r"shapeFilter",
      r"(Ljava/util/function/Predicate;)Lsoftware/amazon/smithy/model/shapes/ModelSerializer$Builder;");

  /// from: public software.amazon.smithy.model.shapes.ModelSerializer.Builder shapeFilter(java.util.function.Predicate<software.amazon.smithy.model.shapes.Shape> shapeFilter)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Predicate that determines if a shape and its traits are serialized.
  ///@param shapeFilter Predicate that accepts a shape.
  ///@return Returns the builder.
  ModelSerializer_Builder shapeFilter(
    jni.JObject shapeFilter,
  ) {
    return const $ModelSerializer_BuilderType().fromRef(jniAccessors
        .callMethodWithArgs(reference, _id_shapeFilter,
            jni.JniCallType.objectType, [shapeFilter.reference]).object);
  }

  static final _id_includePrelude = jniAccessors.getMethodIDOf(
      _classRef,
      r"includePrelude",
      r"(Z)Lsoftware/amazon/smithy/model/shapes/ModelSerializer$Builder;");

  /// from: public software.amazon.smithy.model.shapes.ModelSerializer.Builder includePrelude(boolean includePrelude)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Enables or disables including the prelude in the serialized model.
  ///
  /// By default, the prelude is not included.
  ///
  /// This should nearly always be left at default, as per the spec the prelude is
  /// inherently part of every model, and so any Smithy implementation must build in
  /// an understanding of the prelude. Disabling this filter can be useful for those
  /// implementations to allow them to build their understanding of it from a JSON
  /// version of the prelude.
  ///@param includePrelude boolean indicating whether the prelude should be included or not.
  ///@return Returns the builder.
  ModelSerializer_Builder includePrelude(
    bool includePrelude,
  ) {
    return const $ModelSerializer_BuilderType().fromRef(jniAccessors
        .callMethodWithArgs(reference, _id_includePrelude,
            jni.JniCallType.objectType, [includePrelude ? 1 : 0]).object);
  }

  static final _id_traitFilter = jniAccessors.getMethodIDOf(
      _classRef,
      r"traitFilter",
      r"(Ljava/util/function/Predicate;)Lsoftware/amazon/smithy/model/shapes/ModelSerializer$Builder;");

  /// from: public software.amazon.smithy.model.shapes.ModelSerializer.Builder traitFilter(java.util.function.Predicate<software.amazon.smithy.model.traits.Trait> traitFilter)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets a predicate that can be used to filter trait values from
  /// appearing in the serialized model.
  ///
  /// Note that this does not filter out trait definitions. It only filters
  /// out instances of traits from being serialized on shapes.
  ///@param traitFilter Predicate that filters out trait definitions.
  ///@return Returns the builder.
  ModelSerializer_Builder traitFilter(
    jni.JObject traitFilter,
  ) {
    return const $ModelSerializer_BuilderType().fromRef(jniAccessors
        .callMethodWithArgs(reference, _id_traitFilter,
            jni.JniCallType.objectType, [traitFilter.reference]).object);
  }

  static final _id_version = jniAccessors.getMethodIDOf(_classRef, r"version",
      r"(Ljava/lang/String;)Lsoftware/amazon/smithy/model/shapes/ModelSerializer$Builder;");

  /// from: public software.amazon.smithy.model.shapes.ModelSerializer.Builder version(java.lang.String version)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the IDL version to serialize. Defaults to 2.0.
  ///
  /// Version "1.0" serialization cannot be used with \#includePrelude.
  ///@param version IDL version to set. Can be "1", "1.0", "2", or "2.0".
  ///                "1" and "2" are normalized to "1.0" and "2.0".
  ///@return Returns the builder.
  ModelSerializer_Builder version(
    jni.JString version,
  ) {
    return const $ModelSerializer_BuilderType().fromRef(jniAccessors
        .callMethodWithArgs(reference, _id_version, jni.JniCallType.objectType,
            [version.reference]).object);
  }

  static final _id_build = jniAccessors.getMethodIDOf(_classRef, r"build",
      r"()Lsoftware/amazon/smithy/model/shapes/ModelSerializer;");

  /// from: public software.amazon.smithy.model.shapes.ModelSerializer build()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ModelSerializer build() {
    return const $ModelSerializerType().fromRef(jniAccessors.callMethodWithArgs(
        reference, _id_build, jni.JniCallType.objectType, []).object);
  }
}

class $ModelSerializer_BuilderType
    extends jni.JObjType<ModelSerializer_Builder> {
  const $ModelSerializer_BuilderType();

  @override
  String get signature =>
      r"Lsoftware/amazon/smithy/model/shapes/ModelSerializer$Builder;";

  @override
  ModelSerializer_Builder fromRef(jni.JObjectPtr ref) =>
      ModelSerializer_Builder.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ModelSerializer_BuilderType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == $ModelSerializer_BuilderType &&
        other is $ModelSerializer_BuilderType;
  }
}

/// from: software.amazon.smithy.model.shapes.ServiceShape
///
/// Represents a {@code service} shape.
class ServiceShape extends jni.JObject {
  @override
  late final jni.JObjType $type = type;

  ServiceShape.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _classRef = jniAccessors
      .getClassOf(r"software/amazon/smithy/model/shapes/ServiceShape");

  /// The type which includes information such as the signature of this class.
  static const type = $ServiceShapeType();
  static final _id_builder = jniAccessors.getStaticMethodIDOf(
      _classRef,
      r"builder",
      r"()Lsoftware/amazon/smithy/model/shapes/ServiceShape$Builder;");

  /// from: static public software.amazon.smithy.model.shapes.ServiceShape.Builder builder()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static ServiceShape_Builder builder() {
    return const $ServiceShape_BuilderType().fromRef(jniAccessors
        .callStaticMethodWithArgs(
            _classRef, _id_builder, jni.JniCallType.objectType, []).object);
  }

  static final _id_toBuilder = jniAccessors.getMethodIDOf(
      _classRef,
      r"toBuilder",
      r"()Lsoftware/amazon/smithy/model/shapes/ServiceShape$Builder;");

  /// from: public software.amazon.smithy.model.shapes.ServiceShape.Builder toBuilder()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ServiceShape_Builder toBuilder() {
    return const $ServiceShape_BuilderType().fromRef(jniAccessors
        .callMethodWithArgs(
            reference, _id_toBuilder, jni.JniCallType.objectType, []).object);
  }

  static final _id_accept = jniAccessors.getMethodIDOf(_classRef, r"accept",
      r"(Lsoftware/amazon/smithy/model/shapes/ShapeVisitor;)Ljava/lang/Object;");

  /// from: public R accept(software.amazon.smithy.model.shapes.ShapeVisitor<R> visitor)
  /// The returned object must be deleted after use, by calling the `delete` method.
  $R accept<$R extends jni.JObject>(
    jni.JObject visitor, {
    required jni.JObjType<$R> R,
  }) {
    return R.fromRef(jniAccessors.callMethodWithArgs(reference, _id_accept,
        jni.JniCallType.objectType, [visitor.reference]).object);
  }

  static final _id_asServiceShape = jniAccessors.getMethodIDOf(
      _classRef, r"asServiceShape", r"()Ljava/util/Optional;");

  /// from: public java.util.Optional<software.amazon.smithy.model.shapes.ServiceShape> asServiceShape()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JObject asServiceShape() {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference, _id_asServiceShape, jni.JniCallType.objectType, []).object);
  }

  static final _id_equals1 = jniAccessors.getMethodIDOf(
      _classRef, r"equals", r"(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object other)
  bool equals1(
    jni.JObject other,
  ) {
    return jniAccessors.callMethodWithArgs(reference, _id_equals1,
        jni.JniCallType.booleanType, [other.reference]).boolean;
  }

  static final _id_getType = jniAccessors.getMethodIDOf(_classRef, r"getType",
      r"()Lsoftware/amazon/smithy/model/shapes/ShapeType;");

  /// from: public software.amazon.smithy.model.shapes.ShapeType getType()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JObject getType() {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference, _id_getType, jni.JniCallType.objectType, []).object);
  }

  static final _id_getVersion = jniAccessors.getMethodIDOf(
      _classRef, r"getVersion", r"()Ljava/lang/String;");

  /// from: public java.lang.String getVersion()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the version of the service. An empty string is returned
  /// if the version is undefined.
  ///@return The version of the service.
  jni.JString getVersion() {
    return const jni.JStringType().fromRef(jniAccessors.callMethodWithArgs(
        reference, _id_getVersion, jni.JniCallType.objectType, []).object);
  }

  static final _id_getIntroducedVersion = jniAccessors.getMethodIDOf(
      _classRef, r"getIntroducedVersion", r"()Ljava/lang/String;");

  /// from: public java.lang.String getIntroducedVersion()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the version of the service introduced by the shape and not
  /// inherited from mixins. An empty string is returned if the version
  /// is undefined.
  ///@return The introduced version of the service.
  jni.JString getIntroducedVersion() {
    return const jni.JStringType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_getIntroducedVersion,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_getRename =
      jniAccessors.getMethodIDOf(_classRef, r"getRename", r"()Ljava/util/Map;");

  /// from: public java.util.Map<software.amazon.smithy.model.shapes.ShapeId,java.lang.String> getRename()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return The rename map of the service.
  jni.JObject getRename() {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference, _id_getRename, jni.JniCallType.objectType, []).object);
  }

  static final _id_getIntroducedRename = jniAccessors.getMethodIDOf(
      _classRef, r"getIntroducedRename", r"()Ljava/util/Map;");

  /// from: public java.util.Map<software.amazon.smithy.model.shapes.ShapeId,java.lang.String> getIntroducedRename()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the rename map introduced by the shape and not inherited
  /// from mixins.
  ///@return The introduced rename map of the service.
  jni.JObject getIntroducedRename() {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_getIntroducedRename,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_getErrors = jniAccessors.getMethodIDOf(
      _classRef, r"getErrors", r"()Ljava/util/List;");

  /// from: public java.util.List<software.amazon.smithy.model.shapes.ShapeId> getErrors()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets a list of the common errors that can be encountered by
  /// every operation in the service.
  ///
  ///
  /// Each returned ShapeId must resolve to a
  /// StructureShape that is targeted by an error trait; however,
  /// this is only guaranteed after a model is validated.
  ///
  ///@return Returns the errors.
  jni.JObject getErrors() {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference, _id_getErrors, jni.JniCallType.objectType, []).object);
  }

  static final _id_getIntroducedErrors = jniAccessors.getMethodIDOf(
      _classRef, r"getIntroducedErrors", r"()Ljava/util/List;");

  /// from: public java.util.List<software.amazon.smithy.model.shapes.ShapeId> getIntroducedErrors()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the list of common errors introduced by the shape and not
  /// inherited from mixins. These errors can be encountered by every
  /// operation in the service.
  ///
  /// Each returned ShapeId must resolve to a
  /// StructureShape that is targeted by an error trait; however,
  /// this is only guaranteed after a model is validated.
  ///@return Returns the introduced service errors.
  jni.JObject getIntroducedErrors() {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_getIntroducedErrors,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_getContextualName = jniAccessors.getMethodIDOf(
      _classRef,
      r"getContextualName",
      r"(Lsoftware/amazon/smithy/model/shapes/ToShapeId;)Ljava/lang/String;");

  /// from: public java.lang.String getContextualName(software.amazon.smithy.model.shapes.ToShapeId shape)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the contextual name of a shape within the closure.
  ///
  /// If there is a rename property entry for the given shape ID, then
  /// the renamed shape name is returned. Otherwise, the name part of the
  /// given shape ID is returned, regardless of if the shape exists in the
  /// closure of the service.
  ///
  /// This is a mirror of ShapeId\#getName(ServiceShape)
  /// that serves to make this functionality more discoverable.
  ///@param shape Shape to get the contextual name of.
  ///@return Returns the contextual name of the shape within the service.
  jni.JString getContextualName(
    jni.JObject shape,
  ) {
    return const jni.JStringType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_getContextualName,
        jni.JniCallType.objectType,
        [shape.reference]).object);
  }
}

class $ServiceShapeType extends jni.JObjType<ServiceShape> {
  const $ServiceShapeType();

  @override
  String get signature => r"Lsoftware/amazon/smithy/model/shapes/ServiceShape;";

  @override
  ServiceShape fromRef(jni.JObjectPtr ref) => ServiceShape.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ServiceShapeType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == $ServiceShapeType && other is $ServiceShapeType;
  }
}

/// from: software.amazon.smithy.model.shapes.ServiceShape$Builder
///
/// Builder used to create a ServiceShape.
class ServiceShape_Builder extends jni.JObject {
  @override
  late final jni.JObjType $type = type;

  ServiceShape_Builder.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _classRef = jniAccessors
      .getClassOf(r"software/amazon/smithy/model/shapes/ServiceShape$Builder");

  /// The type which includes information such as the signature of this class.
  static const type = $ServiceShape_BuilderType();
  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, r"<init>", r"()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  factory ServiceShape_Builder() {
    return ServiceShape_Builder.fromRef(
        jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);
  }

  static final _id_build = jniAccessors.getMethodIDOf(_classRef, r"build",
      r"()Lsoftware/amazon/smithy/model/shapes/ServiceShape;");

  /// from: public software.amazon.smithy.model.shapes.ServiceShape build()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ServiceShape build() {
    return const $ServiceShapeType().fromRef(jniAccessors.callMethodWithArgs(
        reference, _id_build, jni.JniCallType.objectType, []).object);
  }

  static final _id_getShapeType = jniAccessors.getMethodIDOf(_classRef,
      r"getShapeType", r"()Lsoftware/amazon/smithy/model/shapes/ShapeType;");

  /// from: public software.amazon.smithy.model.shapes.ShapeType getShapeType()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JObject getShapeType() {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference, _id_getShapeType, jni.JniCallType.objectType, []).object);
  }

  static final _id_version = jniAccessors.getMethodIDOf(_classRef, r"version",
      r"(Ljava/lang/String;)Lsoftware/amazon/smithy/model/shapes/ServiceShape$Builder;");

  /// from: public software.amazon.smithy.model.shapes.ServiceShape.Builder version(java.lang.String version)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ServiceShape_Builder version(
    jni.JString version,
  ) {
    return const $ServiceShape_BuilderType().fromRef(jniAccessors
        .callMethodWithArgs(reference, _id_version, jni.JniCallType.objectType,
            [version.reference]).object);
  }

  static final _id_clearRename = jniAccessors.getMethodIDOf(
      _classRef,
      r"clearRename",
      r"()Lsoftware/amazon/smithy/model/shapes/ServiceShape$Builder;");

  /// from: public software.amazon.smithy.model.shapes.ServiceShape.Builder clearRename()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ServiceShape_Builder clearRename() {
    return const $ServiceShape_BuilderType().fromRef(jniAccessors
        .callMethodWithArgs(
            reference, _id_clearRename, jni.JniCallType.objectType, []).object);
  }

  static final _id_rename = jniAccessors.getMethodIDOf(_classRef, r"rename",
      r"(Ljava/util/Map;)Lsoftware/amazon/smithy/model/shapes/ServiceShape$Builder;");

  /// from: public software.amazon.smithy.model.shapes.ServiceShape.Builder rename(java.util.Map<software.amazon.smithy.model.shapes.ShapeId,java.lang.String> rename)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ServiceShape_Builder rename(
    jni.JObject rename,
  ) {
    return const $ServiceShape_BuilderType().fromRef(jniAccessors
        .callMethodWithArgs(reference, _id_rename, jni.JniCallType.objectType,
            [rename.reference]).object);
  }

  static final _id_putRename = jniAccessors.getMethodIDOf(
      _classRef,
      r"putRename",
      r"(Lsoftware/amazon/smithy/model/shapes/ShapeId;Ljava/lang/String;)Lsoftware/amazon/smithy/model/shapes/ServiceShape$Builder;");

  /// from: public software.amazon.smithy.model.shapes.ServiceShape.Builder putRename(software.amazon.smithy.model.shapes.ShapeId from, java.lang.String to)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ServiceShape_Builder putRename(
    jni.JObject from,
    jni.JString to,
  ) {
    return const $ServiceShape_BuilderType().fromRef(jniAccessors
        .callMethodWithArgs(reference, _id_putRename,
            jni.JniCallType.objectType, [from.reference, to.reference]).object);
  }

  static final _id_removeRename = jniAccessors.getMethodIDOf(
      _classRef,
      r"removeRename",
      r"(Lsoftware/amazon/smithy/model/shapes/ToShapeId;)Lsoftware/amazon/smithy/model/shapes/ServiceShape$Builder;");

  /// from: public software.amazon.smithy.model.shapes.ServiceShape.Builder removeRename(software.amazon.smithy.model.shapes.ToShapeId from)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ServiceShape_Builder removeRename(
    jni.JObject from,
  ) {
    return const $ServiceShape_BuilderType().fromRef(jniAccessors
        .callMethodWithArgs(reference, _id_removeRename,
            jni.JniCallType.objectType, [from.reference]).object);
  }

  static final _id_errors = jniAccessors.getMethodIDOf(_classRef, r"errors",
      r"(Ljava/util/Collection;)Lsoftware/amazon/smithy/model/shapes/ServiceShape$Builder;");

  /// from: public software.amazon.smithy.model.shapes.ServiceShape.Builder errors(java.util.Collection<software.amazon.smithy.model.shapes.ShapeId> errorShapeIds)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets and replaces the errors of the service. Each error is implicitly
  /// bound to every operation within the closure of the service.
  ///@param errorShapeIds Error shape IDs to set.
  ///@return Returns the builder.
  ServiceShape_Builder errors(
    jni.JObject errorShapeIds,
  ) {
    return const $ServiceShape_BuilderType().fromRef(jniAccessors
        .callMethodWithArgs(reference, _id_errors, jni.JniCallType.objectType,
            [errorShapeIds.reference]).object);
  }

  static final _id_addError = jniAccessors.getMethodIDOf(_classRef, r"addError",
      r"(Lsoftware/amazon/smithy/model/shapes/ToShapeId;)Lsoftware/amazon/smithy/model/shapes/ServiceShape$Builder;");

  /// from: public software.amazon.smithy.model.shapes.ServiceShape.Builder addError(software.amazon.smithy.model.shapes.ToShapeId errorShapeId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Adds an error to the service that is implicitly bound to every operation
  /// within the closure of the service.
  ///@param errorShapeId Error shape ID to add.
  ///@return Returns the builder.
  ServiceShape_Builder addError(
    jni.JObject errorShapeId,
  ) {
    return const $ServiceShape_BuilderType().fromRef(jniAccessors
        .callMethodWithArgs(reference, _id_addError, jni.JniCallType.objectType,
            [errorShapeId.reference]).object);
  }

  static final _id_addError1 = jniAccessors.getMethodIDOf(
      _classRef,
      r"addError",
      r"(Ljava/lang/String;)Lsoftware/amazon/smithy/model/shapes/ServiceShape$Builder;");

  /// from: public software.amazon.smithy.model.shapes.ServiceShape.Builder addError(java.lang.String errorShapeId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Adds an error to the service that is implicitly bound to every
  /// operation within the closure of the service.
  ///@param errorShapeId Error shape ID to add.
  ///@return Returns the builder.
  ///@throws ShapeIdSyntaxException if the shape ID is invalid.
  ServiceShape_Builder addError1(
    jni.JString errorShapeId,
  ) {
    return const $ServiceShape_BuilderType().fromRef(jniAccessors
        .callMethodWithArgs(reference, _id_addError1,
            jni.JniCallType.objectType, [errorShapeId.reference]).object);
  }

  static final _id_addErrors = jniAccessors.getMethodIDOf(
      _classRef,
      r"addErrors",
      r"(Ljava/util/List;)Lsoftware/amazon/smithy/model/shapes/ServiceShape$Builder;");

  /// from: public software.amazon.smithy.model.shapes.ServiceShape.Builder addErrors(java.util.List<software.amazon.smithy.model.shapes.ShapeId> errorShapeIds)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Adds errors to the service that are implicitly bound to every operation
  /// within the closure of the service.
  ///@param errorShapeIds Error shape IDs to add.
  ///@return Returns the builder.
  ServiceShape_Builder addErrors(
    jni.JObject errorShapeIds,
  ) {
    return const $ServiceShape_BuilderType().fromRef(jniAccessors
        .callMethodWithArgs(reference, _id_addErrors,
            jni.JniCallType.objectType, [errorShapeIds.reference]).object);
  }

  static final _id_removeError = jniAccessors.getMethodIDOf(
      _classRef,
      r"removeError",
      r"(Lsoftware/amazon/smithy/model/shapes/ToShapeId;)Lsoftware/amazon/smithy/model/shapes/ServiceShape$Builder;");

  /// from: public software.amazon.smithy.model.shapes.ServiceShape.Builder removeError(software.amazon.smithy.model.shapes.ToShapeId errorShapeId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Removes an error by Shape ID.
  ///@param errorShapeId Error shape ID to remove.
  ///@return Returns the builder.
  ServiceShape_Builder removeError(
    jni.JObject errorShapeId,
  ) {
    return const $ServiceShape_BuilderType().fromRef(jniAccessors
        .callMethodWithArgs(reference, _id_removeError,
            jni.JniCallType.objectType, [errorShapeId.reference]).object);
  }

  static final _id_clearErrors = jniAccessors.getMethodIDOf(
      _classRef,
      r"clearErrors",
      r"()Lsoftware/amazon/smithy/model/shapes/ServiceShape$Builder;");

  /// from: public software.amazon.smithy.model.shapes.ServiceShape.Builder clearErrors()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Removes all errors.
  ///@return Returns the builder.
  ServiceShape_Builder clearErrors() {
    return const $ServiceShape_BuilderType().fromRef(jniAccessors
        .callMethodWithArgs(
            reference, _id_clearErrors, jni.JniCallType.objectType, []).object);
  }

  static final _id_flattenMixins = jniAccessors.getMethodIDOf(
      _classRef,
      r"flattenMixins",
      r"()Lsoftware/amazon/smithy/model/shapes/ServiceShape$Builder;");

  /// from: public software.amazon.smithy.model.shapes.ServiceShape.Builder flattenMixins()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ServiceShape_Builder flattenMixins() {
    return const $ServiceShape_BuilderType().fromRef(jniAccessors
        .callMethodWithArgs(reference, _id_flattenMixins,
            jni.JniCallType.objectType, []).object);
  }
}

class $ServiceShape_BuilderType extends jni.JObjType<ServiceShape_Builder> {
  const $ServiceShape_BuilderType();

  @override
  String get signature =>
      r"Lsoftware/amazon/smithy/model/shapes/ServiceShape$Builder;";

  @override
  ServiceShape_Builder fromRef(jni.JObjectPtr ref) =>
      ServiceShape_Builder.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ServiceShape_BuilderType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == $ServiceShape_BuilderType &&
        other is $ServiceShape_BuilderType;
  }
}

/// from: software.amazon.smithy.model.transform.ModelTransformer
///
/// Class used to transform Models.
class ModelTransformer extends jni.JObject {
  @override
  late final jni.JObjType $type = type;

  ModelTransformer.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _classRef = jniAccessors
      .getClassOf(r"software/amazon/smithy/model/transform/ModelTransformer");

  /// The type which includes information such as the signature of this class.
  static const type = $ModelTransformerType();
  static final _id_create = jniAccessors.getStaticMethodIDOf(
      _classRef,
      r"create",
      r"()Lsoftware/amazon/smithy/model/transform/ModelTransformer;");

  /// from: static public software.amazon.smithy.model.transform.ModelTransformer create()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a ModelTransformer using ModelTransformerPlugin instances
  /// discovered using the {@code com.software.smithy.transform} class
  /// loader and any modules found in the module path.
  ///@return Returns the created ModelTransformer.
  static ModelTransformer create() {
    return const $ModelTransformerType().fromRef(jniAccessors
        .callStaticMethodWithArgs(
            _classRef, _id_create, jni.JniCallType.objectType, []).object);
  }

  static final _id_createWithPlugins = jniAccessors.getStaticMethodIDOf(
      _classRef,
      r"createWithPlugins",
      r"(Ljava/util/List;)Lsoftware/amazon/smithy/model/transform/ModelTransformer;");

  /// from: static public software.amazon.smithy.model.transform.ModelTransformer createWithPlugins(java.util.List<software.amazon.smithy.model.transform.ModelTransformerPlugin> plugins)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a ModelTransformer using a list of ModelTransformer plugins.
  ///@param plugins Plugins to use with the transformer.
  ///@return Returns the created ModelTransformer.
  static ModelTransformer createWithPlugins(
    jni.JObject plugins,
  ) {
    return const $ModelTransformerType().fromRef(jniAccessors
        .callStaticMethodWithArgs(_classRef, _id_createWithPlugins,
            jni.JniCallType.objectType, [plugins.reference]).object);
  }

  static final _id_createWithServiceProviders = jniAccessors.getStaticMethodIDOf(
      _classRef,
      r"createWithServiceProviders",
      r"(Ljava/lang/ClassLoader;)Lsoftware/amazon/smithy/model/transform/ModelTransformer;");

  /// from: static public software.amazon.smithy.model.transform.ModelTransformer createWithServiceProviders(java.lang.ClassLoader classLoader)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a ModelTransformer that finds ModelTransformerPlugin
  /// service providers using the given ClassLoader.
  ///@param classLoader ClassLoader used to find ModelTransformerPlugin instances.
  ///@return Returns the created ModelTransformer.
  static ModelTransformer createWithServiceProviders(
    jni.JObject classLoader,
  ) {
    return const $ModelTransformerType().fromRef(jniAccessors
        .callStaticMethodWithArgs(_classRef, _id_createWithServiceProviders,
            jni.JniCallType.objectType, [classLoader.reference]).object);
  }

  static final _id_replaceShapes = jniAccessors.getMethodIDOf(
      _classRef,
      r"replaceShapes",
      r"(Lsoftware/amazon/smithy/model/Model;Ljava/util/Collection;)Lsoftware/amazon/smithy/model/Model;");

  /// from: public software.amazon.smithy.model.Model replaceShapes(software.amazon.smithy.model.Model model, java.util.Collection<? extends software.amazon.smithy.model.shapes.Shape> shapes)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Adds or replaces shapes into the model while ensuring that the model
  /// is in a consistent state.
  ///@param model Model to transform.
  ///@param shapes Shapes to add or replace in the model.base.
  ///@return Returns the transformed model.base.
  Model replaceShapes(
    Model model,
    jni.JObject shapes,
  ) {
    return const $ModelType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_replaceShapes,
        jni.JniCallType.objectType,
        [model.reference, shapes.reference]).object);
  }

  static final _id_removeShapes = jniAccessors.getMethodIDOf(
      _classRef,
      r"removeShapes",
      r"(Lsoftware/amazon/smithy/model/Model;Ljava/util/Collection;)Lsoftware/amazon/smithy/model/Model;");

  /// from: public software.amazon.smithy.model.Model removeShapes(software.amazon.smithy.model.Model model, java.util.Collection<? extends software.amazon.smithy.model.shapes.Shape> shapes)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Removes shapes from the model while ensuring that the model is in a
  /// consistent state.
  ///@param model Model to transform.
  ///@param shapes Shapes to add or replace in the model.base.
  ///@return Returns the transformed model.base.
  Model removeShapes(
    Model model,
    jni.JObject shapes,
  ) {
    return const $ModelType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_removeShapes,
        jni.JniCallType.objectType,
        [model.reference, shapes.reference]).object);
  }

  static final _id_removeShapesIf = jniAccessors.getMethodIDOf(
      _classRef,
      r"removeShapesIf",
      r"(Lsoftware/amazon/smithy/model/Model;Ljava/util/function/Predicate;)Lsoftware/amazon/smithy/model/Model;");

  /// from: public software.amazon.smithy.model.Model removeShapesIf(software.amazon.smithy.model.Model model, java.util.function.Predicate<software.amazon.smithy.model.shapes.Shape> predicate)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Removes shapes from the model that match the given predicate.
  ///@param model Model to transform.
  ///@param predicate Predicate that accepts a shape and returns true to
  ///  remove it.
  ///@return Returns the transformed model.base.
  Model removeShapesIf(
    Model model,
    jni.JObject predicate,
  ) {
    return const $ModelType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_removeShapesIf,
        jni.JniCallType.objectType,
        [model.reference, predicate.reference]).object);
  }

  static final _id_renameShapes = jniAccessors.getMethodIDOf(
      _classRef,
      r"renameShapes",
      r"(Lsoftware/amazon/smithy/model/Model;Ljava/util/Map;)Lsoftware/amazon/smithy/model/Model;");

  /// from: public software.amazon.smithy.model.Model renameShapes(software.amazon.smithy.model.Model model, java.util.Map<software.amazon.smithy.model.shapes.ShapeId,software.amazon.smithy.model.shapes.ShapeId> renamed)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Renames shapes using ShapeId pairs while ensuring that the
  ///  transformed model is in a consistent state.
  ///
  ///  This transformer ensures that when an aggregate shape is renamed, all
  ///  members are updated in the model.
  ///@param model Model to transform.
  ///@param renamed Map of shapeIds
  ///@return Returns the transformed model.base.
  Model renameShapes(
    Model model,
    jni.JObject renamed,
  ) {
    return const $ModelType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_renameShapes,
        jni.JniCallType.objectType,
        [model.reference, renamed.reference]).object);
  }

  static final _id_renameShapes1 = jniAccessors.getMethodIDOf(
      _classRef,
      r"renameShapes",
      r"(Lsoftware/amazon/smithy/model/Model;Ljava/util/Map;Ljava/util/function/Supplier;)Lsoftware/amazon/smithy/model/Model;");

  /// from: public software.amazon.smithy.model.Model renameShapes(software.amazon.smithy.model.Model model, java.util.Map<software.amazon.smithy.model.shapes.ShapeId,software.amazon.smithy.model.shapes.ShapeId> renamed, java.util.function.Supplier<software.amazon.smithy.model.loader.ModelAssembler> modelAssemblerSupplier)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Renames shapes using ShapeId pairs while ensuring that the
  ///  transformed model is in a consistent state.
  ///
  ///  This transformer ensures that when an aggregate shape is renamed, all
  ///  members are updated in the model.
  ///@param model Model to transform.
  ///@param renamed Map of shapeIds
  ///@param modelAssemblerSupplier Supplier used to create ModelAssemblers in each transform.
  ///@return Returns the transformed model.
  Model renameShapes1(
    Model model,
    jni.JObject renamed,
    jni.JObject modelAssemblerSupplier,
  ) {
    return const $ModelType().fromRef(jniAccessors.callMethodWithArgs(
        reference, _id_renameShapes1, jni.JniCallType.objectType, [
      model.reference,
      renamed.reference,
      modelAssemblerSupplier.reference
    ]).object);
  }

  static final _id_filterShapes = jniAccessors.getMethodIDOf(
      _classRef,
      r"filterShapes",
      r"(Lsoftware/amazon/smithy/model/Model;Ljava/util/function/Predicate;)Lsoftware/amazon/smithy/model/Model;");

  /// from: public software.amazon.smithy.model.Model filterShapes(software.amazon.smithy.model.Model model, java.util.function.Predicate<software.amazon.smithy.model.shapes.Shape> predicate)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Filters shapes out of the model that do not match the given predicate.
  ///
  /// This filter will never filter out shapes that are part of the
  /// prelude. Use the \#removeShapes method directly if you need
  /// to remove traits that are in the prelude.
  ///@param model Model to transform.
  ///@param predicate Predicate that filters shapes.
  ///@return Returns the transformed model.
  Model filterShapes(
    Model model,
    jni.JObject predicate,
  ) {
    return const $ModelType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_filterShapes,
        jni.JniCallType.objectType,
        [model.reference, predicate.reference]).object);
  }

  static final _id_filterTraits = jniAccessors.getMethodIDOf(
      _classRef,
      r"filterTraits",
      r"(Lsoftware/amazon/smithy/model/Model;Ljava/util/function/BiPredicate;)Lsoftware/amazon/smithy/model/Model;");

  /// from: public software.amazon.smithy.model.Model filterTraits(software.amazon.smithy.model.Model model, java.util.function.BiPredicate<software.amazon.smithy.model.shapes.Shape,software.amazon.smithy.model.traits.Trait> predicate)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Filters traits out of the model that do not match the given predicate.
  ///
  /// The predicate function accepts the shape that a trait is attached to
  /// and the trait. If the predicate returns false, then the trait is
  /// removed from the shape.
  ///@param model Model to transform.
  ///@param predicate Predicate that accepts a (Shape, Trait) and returns
  ///  false if the trait should be removed.
  ///@return Returns the transformed model.base.
  Model filterTraits(
    Model model,
    jni.JObject predicate,
  ) {
    return const $ModelType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_filterTraits,
        jni.JniCallType.objectType,
        [model.reference, predicate.reference]).object);
  }

  static final _id_removeTraitsIf = jniAccessors.getMethodIDOf(
      _classRef,
      r"removeTraitsIf",
      r"(Lsoftware/amazon/smithy/model/Model;Ljava/util/function/BiPredicate;)Lsoftware/amazon/smithy/model/Model;");

  /// from: public software.amazon.smithy.model.Model removeTraitsIf(software.amazon.smithy.model.Model model, java.util.function.BiPredicate<software.amazon.smithy.model.shapes.Shape,software.amazon.smithy.model.traits.Trait> predicate)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Filters traits out of the model that match a predicate function.
  ///
  /// The predicate function accepts the shape that a trait is attached to
  /// and the trait. If the predicate returns true, then the trait is removed
  /// from the shape.
  ///@param model Model to transform.
  ///@param predicate Predicate that accepts a (Shape, Trait) and returns
  ///  true if the trait should be removed.
  ///@return Returns the transformed model.base.
  Model removeTraitsIf(
    Model model,
    jni.JObject predicate,
  ) {
    return const $ModelType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_removeTraitsIf,
        jni.JniCallType.objectType,
        [model.reference, predicate.reference]).object);
  }

  static final _id_filterMetadata = jniAccessors.getMethodIDOf(
      _classRef,
      r"filterMetadata",
      r"(Lsoftware/amazon/smithy/model/Model;Ljava/util/function/BiPredicate;)Lsoftware/amazon/smithy/model/Model;");

  /// from: public software.amazon.smithy.model.Model filterMetadata(software.amazon.smithy.model.Model model, java.util.function.BiPredicate<java.lang.String,software.amazon.smithy.model.node.Node> predicate)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Filters out metadata key-value pairs from a model that do not match
  /// a predicate.
  ///@param model Model to transform.
  ///@param predicate A predicate that accepts a metadata key-value pair.
  ///  If the predicate returns true, then the metadata key-value pair is
  ///  kept. Otherwise, it is removed.
  ///@return Returns the transformed model.base.
  Model filterMetadata(
    Model model,
    jni.JObject predicate,
  ) {
    return const $ModelType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_filterMetadata,
        jni.JniCallType.objectType,
        [model.reference, predicate.reference]).object);
  }

  static final _id_mapTraits = jniAccessors.getMethodIDOf(
      _classRef,
      r"mapTraits",
      r"(Lsoftware/amazon/smithy/model/Model;Ljava/util/function/BiFunction;)Lsoftware/amazon/smithy/model/Model;");

  /// from: public software.amazon.smithy.model.Model mapTraits(software.amazon.smithy.model.Model model, java.util.function.BiFunction<software.amazon.smithy.model.shapes.Shape,software.amazon.smithy.model.traits.Trait,software.amazon.smithy.model.traits.Trait> mapper)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Maps over all traits in the model using a mapping function that accepts
  /// the shape the trait is applied to, a trait, and returns a trait,
  /// possibly even a different kind of trait.
  ///
  /// An exception is thrown if a trait is returned that targets a
  /// different shape than the Shape passed into the mapper function.
  ///@param model Model to transform.
  ///@param mapper Mapping function that accepts a (Shape, Trait) and returns
  ///  the mapped Trait.
  ///@return Returns the transformed model.base.
  Model mapTraits(
    Model model,
    jni.JObject mapper,
  ) {
    return const $ModelType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_mapTraits,
        jni.JniCallType.objectType,
        [model.reference, mapper.reference]).object);
  }

  static final _id_mapTraits1 = jniAccessors.getMethodIDOf(
      _classRef,
      r"mapTraits",
      r"(Lsoftware/amazon/smithy/model/Model;Ljava/util/List;)Lsoftware/amazon/smithy/model/Model;");

  /// from: public software.amazon.smithy.model.Model mapTraits(software.amazon.smithy.model.Model model, java.util.List<java.util.function.BiFunction<software.amazon.smithy.model.shapes.Shape,software.amazon.smithy.model.traits.Trait,software.amazon.smithy.model.traits.Trait>> mappers)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Maps over all traits in the model using multiple mapping functions.
  ///
  /// Note: passing in a list of mappers is much more efficient than
  /// invoking {@code mapTraits} multiple times because it reduces the number
  /// of intermediate models that are needed to perform the transformation.
  ///@param model Model to transform.
  ///@param mappers Mapping functions that accepts a (Shape, Trait) and
  ///  returns the mapped Trait.
  ///@return Returns the transformed model.base.
  ///@see \#mapShapes(Model, Function) for more information.
  Model mapTraits1(
    Model model,
    jni.JObject mappers,
  ) {
    return const $ModelType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_mapTraits1,
        jni.JniCallType.objectType,
        [model.reference, mappers.reference]).object);
  }

  static final _id_mapShapes = jniAccessors.getMethodIDOf(
      _classRef,
      r"mapShapes",
      r"(Lsoftware/amazon/smithy/model/Model;Ljava/util/function/Function;)Lsoftware/amazon/smithy/model/Model;");

  /// from: public software.amazon.smithy.model.Model mapShapes(software.amazon.smithy.model.Model model, java.util.function.Function<software.amazon.smithy.model.shapes.Shape,software.amazon.smithy.model.shapes.Shape> mapper)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Maps over all shapes in the model using a mapping function, allowing
  /// shapes to be replaced with completely different shapes or slightly
  /// modified shapes.
  ///
  /// An exception is thrown if a mapper returns a shape with a different
  /// shape ID or a different type.
  ///@param model Model to transform.
  ///@param mapper Mapping function that accepts a shape and returns a shape
  ///  with the same ID.
  ///@return Returns the transformed model.base.
  Model mapShapes(
    Model model,
    jni.JObject mapper,
  ) {
    return const $ModelType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_mapShapes,
        jni.JniCallType.objectType,
        [model.reference, mapper.reference]).object);
  }

  static final _id_mapShapes1 = jniAccessors.getMethodIDOf(
      _classRef,
      r"mapShapes",
      r"(Lsoftware/amazon/smithy/model/Model;Ljava/util/List;)Lsoftware/amazon/smithy/model/Model;");

  /// from: public software.amazon.smithy.model.Model mapShapes(software.amazon.smithy.model.Model model, java.util.List<java.util.function.Function<software.amazon.smithy.model.shapes.Shape,software.amazon.smithy.model.shapes.Shape>> mappers)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Maps over all shapes in the model using multiple mapping functions.
  ///
  /// Note: passing in a list of mappers is much more efficient than
  /// invoking {@code mapShapes}  multiple times because it reduces the
  /// number of intermediate models that are needed to perform the
  /// transformation.
  ///@param model Model to transform.
  ///@param mappers Mapping functions that accepts a shape and returns a
  ///  shape with the same ID.
  ///@return Returns the transformed model.base.
  ///@see \#mapShapes(Model, Function) for more information.
  Model mapShapes1(
    Model model,
    jni.JObject mappers,
  ) {
    return const $ModelType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_mapShapes1,
        jni.JniCallType.objectType,
        [model.reference, mappers.reference]).object);
  }

  static final _id_removeUnreferencedShapes = jniAccessors.getMethodIDOf(
      _classRef,
      r"removeUnreferencedShapes",
      r"(Lsoftware/amazon/smithy/model/Model;)Lsoftware/amazon/smithy/model/Model;");

  /// from: public software.amazon.smithy.model.Model removeUnreferencedShapes(software.amazon.smithy.model.Model model)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Removes shapes (excluding service shapes) that are not referenced by
  /// any other shapes.
  ///@param model Model to transform.
  ///@return Returns the transformed model.base.
  Model removeUnreferencedShapes(
    Model model,
  ) {
    return const $ModelType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_removeUnreferencedShapes,
        jni.JniCallType.objectType,
        [model.reference]).object);
  }

  static final _id_removeUnreferencedShapes1 = jniAccessors.getMethodIDOf(
      _classRef,
      r"removeUnreferencedShapes",
      r"(Lsoftware/amazon/smithy/model/Model;Ljava/util/function/Predicate;)Lsoftware/amazon/smithy/model/Model;");

  /// from: public software.amazon.smithy.model.Model removeUnreferencedShapes(software.amazon.smithy.model.Model model, java.util.function.Predicate<software.amazon.smithy.model.shapes.Shape> keepFilter)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Removes shapes (excluding service shapes) that are not referenced by
  /// any other shapes.
  ///
  /// Shapes that are part of the prelude or that act as the shape of any
  /// trait, regardless of if the trait is in use in the model, are never
  /// considered unreferenced.
  ///@param model Model to transform.
  ///@param keepFilter Predicate function that accepts an unreferenced
  ///  shape and returns true to remove the shape or false to keep the shape
  ///  in the model.base.
  ///@return Returns the transformed model.base.
  Model removeUnreferencedShapes1(
    Model model,
    jni.JObject keepFilter,
  ) {
    return const $ModelType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_removeUnreferencedShapes1,
        jni.JniCallType.objectType,
        [model.reference, keepFilter.reference]).object);
  }

  static final _id_removeUnreferencedTraitDefinitions = jniAccessors.getMethodIDOf(
      _classRef,
      r"removeUnreferencedTraitDefinitions",
      r"(Lsoftware/amazon/smithy/model/Model;)Lsoftware/amazon/smithy/model/Model;");

  /// from: public software.amazon.smithy.model.Model removeUnreferencedTraitDefinitions(software.amazon.smithy.model.Model model)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Removes definitions for traits that are not used by any shape in the
  /// model.base.
  ///
  /// Trait definitions that are part of the prelude will not be removed.
  ///@param model Model to transform
  ///@return Returns the transformed model.base.
  Model removeUnreferencedTraitDefinitions(
    Model model,
  ) {
    return const $ModelType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_removeUnreferencedTraitDefinitions,
        jni.JniCallType.objectType,
        [model.reference]).object);
  }

  static final _id_removeUnreferencedTraitDefinitions1 = jniAccessors.getMethodIDOf(
      _classRef,
      r"removeUnreferencedTraitDefinitions",
      r"(Lsoftware/amazon/smithy/model/Model;Ljava/util/function/Predicate;)Lsoftware/amazon/smithy/model/Model;");

  /// from: public software.amazon.smithy.model.Model removeUnreferencedTraitDefinitions(software.amazon.smithy.model.Model model, java.util.function.Predicate<software.amazon.smithy.model.shapes.Shape> keepFilter)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Removes trait definitions for traits that are not used by any shape
  /// in the model.
  ///
  /// Trait definitions that are part of the prelude will not be removed.
  ///@param model Model to transform
  ///@param keepFilter Predicate function that accepts an unreferenced trait
  ///  shape (that has the TraitDefinition trait) and returns true to
  ///  remove the definition or false to keep the definition in the model.base.
  ///@return Returns the transformed model.base.
  Model removeUnreferencedTraitDefinitions1(
    Model model,
    jni.JObject keepFilter,
  ) {
    return const $ModelType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_removeUnreferencedTraitDefinitions1,
        jni.JniCallType.objectType,
        [model.reference, keepFilter.reference]).object);
  }

  static final _id_scrubTraitDefinitions = jniAccessors.getMethodIDOf(
      _classRef,
      r"scrubTraitDefinitions",
      r"(Lsoftware/amazon/smithy/model/Model;)Lsoftware/amazon/smithy/model/Model;");

  /// from: public software.amazon.smithy.model.Model scrubTraitDefinitions(software.amazon.smithy.model.Model model)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Removes all trait definitions from a model and all shapes that are
  /// only connected to the graph either directly or transitively by a
  /// trait definition shape.
  ///
  /// This can be useful when serializing a Smithy model to a format that
  /// does not include trait definitions and the shapes used by trait definitions
  /// would have no meaning (e.g., OpenAPI).
  ///@param model Model to transform.
  ///@return Returns the transformed model.base.
  Model scrubTraitDefinitions(
    Model model,
  ) {
    return const $ModelType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_scrubTraitDefinitions,
        jni.JniCallType.objectType,
        [model.reference]).object);
  }

  static final _id_scrubTraitDefinitions1 = jniAccessors.getMethodIDOf(
      _classRef,
      r"scrubTraitDefinitions",
      r"(Lsoftware/amazon/smithy/model/Model;Ljava/util/function/Predicate;)Lsoftware/amazon/smithy/model/Model;");

  /// from: public software.amazon.smithy.model.Model scrubTraitDefinitions(software.amazon.smithy.model.Model model, java.util.function.Predicate<software.amazon.smithy.model.shapes.Shape> keepFilter)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Removes trait definitions from a model and all shapes that are
  /// only connected to the graph either directly or transitively by a
  /// trait definition shape.
  ///
  /// This can be useful when serializing a Smithy model to a format that
  /// does not include trait definitions and the shapes used by trait definitions
  /// would have no meaning (e.g., OpenAPI).
  ///@param model Model to transform.
  ///@param keepFilter Predicate function that accepts an trait shape (that
  ///  has the TraitDefinition trait) and returns true to remove the
  ///  definition or false to keep the definition in the model.
  ///@return Returns the transformed model.
  Model scrubTraitDefinitions1(
    Model model,
    jni.JObject keepFilter,
  ) {
    return const $ModelType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_scrubTraitDefinitions1,
        jni.JniCallType.objectType,
        [model.reference, keepFilter.reference]).object);
  }

  static final _id_getModelWithoutTraitShapes = jniAccessors.getMethodIDOf(
      _classRef,
      r"getModelWithoutTraitShapes",
      r"(Lsoftware/amazon/smithy/model/Model;)Lsoftware/amazon/smithy/model/Model;");

  /// from: public software.amazon.smithy.model.Model getModelWithoutTraitShapes(software.amazon.smithy.model.Model model)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets all shapes from a model where shapes that define traits or shapes
  /// that are only used as part of a trait definition have been removed.
  ///@param model Model that contains shapes.
  ///@return Returns a model that contains matching shapes.
  Model getModelWithoutTraitShapes(
    Model model,
  ) {
    return const $ModelType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_getModelWithoutTraitShapes,
        jni.JniCallType.objectType,
        [model.reference]).object);
  }

  static final _id_getModelWithoutTraitShapes1 = jniAccessors.getMethodIDOf(
      _classRef,
      r"getModelWithoutTraitShapes",
      r"(Lsoftware/amazon/smithy/model/Model;Ljava/util/function/Predicate;)Lsoftware/amazon/smithy/model/Model;");

  /// from: public software.amazon.smithy.model.Model getModelWithoutTraitShapes(software.amazon.smithy.model.Model model, java.util.function.Predicate<software.amazon.smithy.model.shapes.Shape> keepFilter)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets all shapes from a model where shapes that define traits or shapes
  /// that are only used as part of a trait definition have been removed.
  ///@param model Model that contains shapes.
  ///@param keepFilter Predicate function that accepts a trait shape (that
  ///  has the TraitDefinition trait) and returns true to remove the
  ///  definition or false to keep the definition in the model.
  ///@return Returns a model that contains matching shapes.
  Model getModelWithoutTraitShapes1(
    Model model,
    jni.JObject keepFilter,
  ) {
    return const $ModelType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_getModelWithoutTraitShapes1,
        jni.JniCallType.objectType,
        [model.reference, keepFilter.reference]).object);
  }

  static final _id_sortMembers = jniAccessors.getMethodIDOf(
      _classRef,
      r"sortMembers",
      r"(Lsoftware/amazon/smithy/model/Model;Ljava/util/Comparator;)Lsoftware/amazon/smithy/model/Model;");

  /// from: public software.amazon.smithy.model.Model sortMembers(software.amazon.smithy.model.Model model, java.util.Comparator<software.amazon.smithy.model.shapes.MemberShape> comparator)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Reorders the members of structure and union shapes using the given
  /// Comparator.
  ///
  /// Note that by default, Smithy models retain the order in which
  /// members are defined in the model. However, in programming languages
  /// where this isn't important, it may be desirable to order members
  /// alphabetically or using some other kind of order.
  ///@param model Model that contains shapes.
  ///@param comparator Comparator used to order members of unions and structures.
  ///@return Returns a model that contains matching shapes.
  Model sortMembers(
    Model model,
    jni.JObject comparator,
  ) {
    return const $ModelType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_sortMembers,
        jni.JniCallType.objectType,
        [model.reference, comparator.reference]).object);
  }

  static final _id_changeShapeType = jniAccessors.getMethodIDOf(
      _classRef,
      r"changeShapeType",
      r"(Lsoftware/amazon/smithy/model/Model;Ljava/util/Map;)Lsoftware/amazon/smithy/model/Model;");

  /// from: public software.amazon.smithy.model.Model changeShapeType(software.amazon.smithy.model.Model model, java.util.Map<software.amazon.smithy.model.shapes.ShapeId,software.amazon.smithy.model.shapes.ShapeType> shapeToType)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Changes the type of each given shape.
  ///
  /// The following transformations are permitted:
  ///
  /// <ul>
  ///     <li>Any simple type to any simple type</li>
  ///     <li>List to set</li>
  ///     <li>Set to list</li>
  ///     <li>Structure to union</li>
  ///     <li>Union to structure</li>
  /// </ul>
  ///@param model Model to transform.
  ///@param shapeToType Map of shape IDs to the new type to use for the shape.
  ///@return Returns the transformed model.
  ///@throws ModelTransformException if an incompatible type transform is attempted.
  Model changeShapeType(
    Model model,
    jni.JObject shapeToType,
  ) {
    return const $ModelType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_changeShapeType,
        jni.JniCallType.objectType,
        [model.reference, shapeToType.reference]).object);
  }

  static final _id_changeShapeType1 = jniAccessors.getMethodIDOf(
      _classRef,
      r"changeShapeType",
      r"(Lsoftware/amazon/smithy/model/Model;Ljava/util/Map;[Lsoftware/amazon/smithy/model/transform/ChangeShapeTypeOption;)Lsoftware/amazon/smithy/model/Model;");

  /// from: public software.amazon.smithy.model.Model changeShapeType(software.amazon.smithy.model.Model model, java.util.Map<software.amazon.smithy.model.shapes.ShapeId,software.amazon.smithy.model.shapes.ShapeType> shapeToType, software.amazon.smithy.model.transform.ChangeShapeTypeOption[] changeShapeTypeOptions)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Changes the type of each given shape.
  ///
  /// The following transformations are permitted:
  ///
  /// <ul>
  ///     <li>Any simple type to any simple type</li>
  ///     <li>List to set</li>
  ///     <li>Set to list</li>
  ///     <li>Structure to union</li>
  ///     <li>Union to structure</li>
  /// </ul>
  ///@param model Model to transform.
  ///@param shapeToType Map of shape IDs to the new type to use for the shape.
  ///@param changeShapeTypeOptions An array of options to enable when changing types.
  ///@return Returns the transformed model.
  ///@throws ModelTransformException if an incompatible type transform is attempted.
  Model changeShapeType1(
    Model model,
    jni.JObject shapeToType,
    jni.JArray<jni.JObject> changeShapeTypeOptions,
  ) {
    return const $ModelType().fromRef(jniAccessors.callMethodWithArgs(
        reference, _id_changeShapeType1, jni.JniCallType.objectType, [
      model.reference,
      shapeToType.reference,
      changeShapeTypeOptions.reference
    ]).object);
  }

  static final _id_changeStringEnumsToEnumShapes = jniAccessors.getMethodIDOf(
      _classRef,
      r"changeStringEnumsToEnumShapes",
      r"(Lsoftware/amazon/smithy/model/Model;Z)Lsoftware/amazon/smithy/model/Model;");

  /// from: public software.amazon.smithy.model.Model changeStringEnumsToEnumShapes(software.amazon.smithy.model.Model model, boolean synthesizeEnumNames)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Changes each compatible string shape with the enum trait to an enum shape.
  ///
  /// A member will be created on the shape for each entry in the EnumTrait.
  ///@param model Model to transform.
  ///@param synthesizeEnumNames Whether enums without names should have names synthesized if possible.
  ///@return Returns the transformed model.
  Model changeStringEnumsToEnumShapes(
    Model model,
    bool synthesizeEnumNames,
  ) {
    return const $ModelType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_changeStringEnumsToEnumShapes,
        jni.JniCallType.objectType,
        [model.reference, synthesizeEnumNames ? 1 : 0]).object);
  }

  static final _id_changeStringEnumsToEnumShapes1 = jniAccessors.getMethodIDOf(
      _classRef,
      r"changeStringEnumsToEnumShapes",
      r"(Lsoftware/amazon/smithy/model/Model;)Lsoftware/amazon/smithy/model/Model;");

  /// from: public software.amazon.smithy.model.Model changeStringEnumsToEnumShapes(software.amazon.smithy.model.Model model)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Changes each compatible string shape with the enum trait to an enum shape.
  ///
  /// A member will be created on the shape for each entry in the EnumTrait.
  ///
  /// Strings with enum traits that don't define names are not converted.
  ///@param model Model to transform.
  ///@return Returns the transformed model.
  Model changeStringEnumsToEnumShapes1(
    Model model,
  ) {
    return const $ModelType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_changeStringEnumsToEnumShapes1,
        jni.JniCallType.objectType,
        [model.reference]).object);
  }

  static final _id_downgradeEnums = jniAccessors.getMethodIDOf(
      _classRef,
      r"downgradeEnums",
      r"(Lsoftware/amazon/smithy/model/Model;)Lsoftware/amazon/smithy/model/Model;");

  /// from: public software.amazon.smithy.model.Model downgradeEnums(software.amazon.smithy.model.Model model)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Changes each enum shape to a string shape and each intEnum to an integer.
  ///@param model Model to transform.
  ///@return Returns the transformed model.
  Model downgradeEnums(
    Model model,
  ) {
    return const $ModelType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_downgradeEnums,
        jni.JniCallType.objectType,
        [model.reference]).object);
  }

  static final _id_copyServiceErrorsToOperations = jniAccessors.getMethodIDOf(
      _classRef,
      r"copyServiceErrorsToOperations",
      r"(Lsoftware/amazon/smithy/model/Model;Lsoftware/amazon/smithy/model/shapes/ServiceShape;)Lsoftware/amazon/smithy/model/Model;");

  /// from: public software.amazon.smithy.model.Model copyServiceErrorsToOperations(software.amazon.smithy.model.Model model, software.amazon.smithy.model.shapes.ServiceShape forService)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Copies the errors defined on the given service onto each operation bound to the
  /// service, effectively flattening service error inheritance.
  ///@param model Model to modify.
  ///@param forService Service shape to use as the basis for copying errors to operations.
  ///@return Returns the transformed model.
  Model copyServiceErrorsToOperations(
    Model model,
    ServiceShape forService,
  ) {
    return const $ModelType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_copyServiceErrorsToOperations,
        jni.JniCallType.objectType,
        [model.reference, forService.reference]).object);
  }

  static final _id_createDedicatedInputAndOutput = jniAccessors.getMethodIDOf(
      _classRef,
      r"createDedicatedInputAndOutput",
      r"(Lsoftware/amazon/smithy/model/Model;Ljava/lang/String;Ljava/lang/String;)Lsoftware/amazon/smithy/model/Model;");

  /// from: public software.amazon.smithy.model.Model createDedicatedInputAndOutput(software.amazon.smithy.model.Model model, java.lang.String inputSuffix, java.lang.String outputSuffix)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Updates the model so that every operation has a dedicated input shape marked
  /// with the {@code input} trait and output shape marked with the {@code output}
  /// trait, and the targeted shapes all have a consistent shape name of
  /// OperationName + {@code inputSuffix} / {@code outputSuffix} depending on the
  /// context.
  ///
  /// If an operation's input already targets a shape marked with the {@code input}
  /// trait, then the existing input shape is used as input, though the shape will
  /// be renamed if it does not use the given {@code inputSuffix}. If an operation's
  /// output already targets a shape marked with the {@code output} trait, then the
  /// existing output shape is used as output, though the shape will be renamed if it
  /// does not use the given {@code outputSuffix}.
  ///
  /// If the operation's input shape starts with the name of the operation and is
  /// only used throughout the model as the input of the operation, then it is updated
  /// to have the {@code input} trait, and the name remains unaltered.
  ///
  /// If the operation's output shape starts with the name of the operation and is
  /// only used throughout the model as the output of the operation, then it is updated
  /// to have the {@code output} trait, and the name remains unaltered.
  ///
  /// If the operation's input shape does not start with the operation's name or
  /// is used in other places throughout the model, a copy of the targeted input
  /// structure is created, the name of the shape becomes OperationName + {@code inputSuffix},
  /// and the {@code input} trait is added to the shape. The operation is then updated
  /// to target the created shape, and the original shape is left as-is in the model.
  ///
  /// If the operation's output shape does not start with the operation's name or
  /// is used in other places throughout the model, a copy of the targeted output
  /// structure is created, the name of the shape becomes OperationName + {@code outputSuffix},
  /// and the {@code output} trait is added to the shape. The operation is then updated
  /// to target the created shape, and the original shape is left as-is in the model.
  ///
  /// If a naming conflict occurs while attempting to create a new shape, then
  /// the default naming conflict resolver will attempt to name the shape
  /// OperationName + "Operation" + {@code inputSuffix} / {@code outputSuffix}
  /// depending on the context. If the name is _still_ in conflict with other
  /// shapes in the model, then a ModelTransformException is thrown.
  ///
  /// Any time a shape is renamed, the original shape ID of the shape is captured
  /// on the shape using the synthetic OriginalShapeIdTrait. This might be
  /// useful for protocols that need to serialize input and output shape names.
  ///@param model Model to update.
  ///@param inputSuffix Suffix to append to dedicated input shapes (e.g., "Input").
  ///@param outputSuffix Suffix to append to dedicated input shapes (e.g., "Output").
  ///@return Returns the updated model.
  ///@throws ModelTransformException if an input or output shape name conflict occurs.
  Model createDedicatedInputAndOutput(
    Model model,
    jni.JString inputSuffix,
    jni.JString outputSuffix,
  ) {
    return const $ModelType().fromRef(jniAccessors.callMethodWithArgs(reference,
        _id_createDedicatedInputAndOutput, jni.JniCallType.objectType, [
      model.reference,
      inputSuffix.reference,
      outputSuffix.reference
    ]).object);
  }

  static final _id_flattenAndRemoveMixins = jniAccessors.getMethodIDOf(
      _classRef,
      r"flattenAndRemoveMixins",
      r"(Lsoftware/amazon/smithy/model/Model;)Lsoftware/amazon/smithy/model/Model;");

  /// from: public software.amazon.smithy.model.Model flattenAndRemoveMixins(software.amazon.smithy.model.Model model)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Flattens mixins out of the model and removes them from the model.
  ///@param model Model to flatten.
  ///@return Returns the flattened model.
  Model flattenAndRemoveMixins(
    Model model,
  ) {
    return const $ModelType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_flattenAndRemoveMixins,
        jni.JniCallType.objectType,
        [model.reference]).object);
  }

  static final _id_addClientOptional = jniAccessors.getMethodIDOf(
      _classRef,
      r"addClientOptional",
      r"(Lsoftware/amazon/smithy/model/Model;Z)Lsoftware/amazon/smithy/model/Model;");

  /// from: public software.amazon.smithy.model.Model addClientOptional(software.amazon.smithy.model.Model model, boolean applyWhenNoDefaultValue)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add the clientOptional trait to members that are effectively nullable because
  /// they are part of a structure marked with the input trait or they aren't required
  /// and don't have a default trait.
  ///@param model Model to transform.
  ///@param applyWhenNoDefaultValue Set to true to add clientOptional to members that target
  ///                                shapes with no zero value (e.g., structure and union).
  ///@return Returns the transformed model.
  Model addClientOptional(
    Model model,
    bool applyWhenNoDefaultValue,
  ) {
    return const $ModelType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_addClientOptional,
        jni.JniCallType.objectType,
        [model.reference, applyWhenNoDefaultValue ? 1 : 0]).object);
  }

  static final _id_downgradeToV1 = jniAccessors.getMethodIDOf(
      _classRef,
      r"downgradeToV1",
      r"(Lsoftware/amazon/smithy/model/Model;)Lsoftware/amazon/smithy/model/Model;");

  /// from: public software.amazon.smithy.model.Model downgradeToV1(software.amazon.smithy.model.Model model)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Removes Smithy IDL 2.0 features from a model that are not strictly necessary to keep for consistency with the
  /// rest of Smithy.
  ///
  /// This transformer is lossy, and converts enum shapes to string shapes with the enum trait, intEnum shapes to
  /// integer shapes, flattens and removes mixins, removes properties from resources, and removes default traits that
  /// have no impact on IDL 1.0 semantics (i.e., default traits on structure members set to something other than null,
  /// or default traits on any other shape that are not the zero value of the shape of a 1.0 model).
  ///@param model Model to downgrade.
  ///@return Returns the downgraded model.
  Model downgradeToV1(
    Model model,
  ) {
    return const $ModelType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_downgradeToV1,
        jni.JniCallType.objectType,
        [model.reference]).object);
  }
}

class $ModelTransformerType extends jni.JObjType<ModelTransformer> {
  const $ModelTransformerType();

  @override
  String get signature =>
      r"Lsoftware/amazon/smithy/model/transform/ModelTransformer;";

  @override
  ModelTransformer fromRef(jni.JObjectPtr ref) => ModelTransformer.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ModelTransformerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == $ModelTransformerType &&
        other is $ModelTransformerType;
  }
}

/// from: software.amazon.smithy.model.validation.ValidatedResult
///
/// Represents the result of an operation and the ValidationEvents
/// that occurred.
///@param <T> The type being created.
class ValidatedResult<$T extends jni.JObject> extends jni.JObject {
  @override
  late final jni.JObjType $type = type(T);

  final jni.JObjType<$T> T;

  ValidatedResult.fromRef(
    this.T,
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _classRef = jniAccessors
      .getClassOf(r"software/amazon/smithy/model/validation/ValidatedResult");

  /// The type which includes information such as the signature of this class.
  static $ValidatedResultType<$T> type<$T extends jni.JObject>(
    jni.JObjType<$T> T,
  ) {
    return $ValidatedResultType(
      T,
    );
  }

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, r"<init>", r"(Ljava/lang/Object;Ljava/util/List;)V");

  /// from: public void <init>(T result, java.util.List<software.amazon.smithy.model.validation.ValidationEvent> events)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a result with a value and events.
  ///@param result Value to set.
  ///@param events Events to set.
  factory ValidatedResult(
    $T result,
    jni.JObject events, {
    jni.JObjType<$T>? T,
  }) {
    T ??= jni.lowestCommonSuperType([
      result.$type,
    ]) as jni.JObjType<$T>;
    return ValidatedResult.fromRef(
        T,
        jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [result.reference, events.reference]).object);
  }

  static final _id_ctor1 = jniAccessors.getMethodIDOf(
      _classRef, r"<init>", r"(Ljava/lang/Object;Ljava/util/Collection;)V");

  /// from: public void <init>(T result, java.util.Collection<software.amazon.smithy.model.validation.ValidationEvent> events)
  /// The returned object must be deleted after use, by calling the `delete` method.
  factory ValidatedResult.ctor1(
    $T result,
    jni.JObject events, {
    jni.JObjType<$T>? T,
  }) {
    T ??= jni.lowestCommonSuperType([
      result.$type,
    ]) as jni.JObjType<$T>;
    return ValidatedResult.fromRef(
        T,
        jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [result.reference, events.reference]).object);
  }

  static final _id_fromErrors = jniAccessors.getStaticMethodIDOf(
      _classRef,
      r"fromErrors",
      r"(Ljava/util/List;)Lsoftware/amazon/smithy/model/validation/ValidatedResult;");

  /// from: static public software.amazon.smithy.model.validation.ValidatedResult<T> fromErrors(java.util.List<software.amazon.smithy.model.validation.ValidationEvent> events)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new ValidatedResult with no values and a list of
  /// ValidationEvents.
  ///@param events Validation events on the result.
  ///@param <T> The type of value in the result.
  ///@return Returns the created ValidatedResult.
  static ValidatedResult<$T> fromErrors<$T extends jni.JObject>(
    jni.JObject events, {
    required jni.JObjType<$T> T,
  }) {
    return $ValidatedResultType(T).fromRef(jniAccessors
        .callStaticMethodWithArgs(_classRef, _id_fromErrors,
            jni.JniCallType.objectType, [events.reference]).object);
  }

  static final _id_fromErrors1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      r"fromErrors",
      r"(Ljava/util/Collection;)Lsoftware/amazon/smithy/model/validation/ValidatedResult;");

  /// from: static public software.amazon.smithy.model.validation.ValidatedResult<T> fromErrors(java.util.Collection<software.amazon.smithy.model.validation.ValidationEvent> events)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static ValidatedResult<$T> fromErrors1<$T extends jni.JObject>(
    jni.JObject events, {
    required jni.JObjType<$T> T,
  }) {
    return $ValidatedResultType(T).fromRef(jniAccessors
        .callStaticMethodWithArgs(_classRef, _id_fromErrors1,
            jni.JniCallType.objectType, [events.reference]).object);
  }

  static final _id_fromValue = jniAccessors.getStaticMethodIDOf(
      _classRef,
      r"fromValue",
      r"(Ljava/lang/Object;)Lsoftware/amazon/smithy/model/validation/ValidatedResult;");

  /// from: static public software.amazon.smithy.model.validation.ValidatedResult<T> fromValue(T value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new ValidatedResult with a value and no
  /// ValidationEvents.
  ///@param value Result value,
  ///@param <T> The type of value in the result.
  ///@return Returns the created ValidatedResult.
  static ValidatedResult<$T> fromValue<$T extends jni.JObject>(
    $T value, {
    jni.JObjType<$T>? T,
  }) {
    T ??= jni.lowestCommonSuperType([
      value.$type,
    ]) as jni.JObjType<$T>;
    return $ValidatedResultType(T).fromRef(jniAccessors
        .callStaticMethodWithArgs(_classRef, _id_fromValue,
            jni.JniCallType.objectType, [value.reference]).object);
  }

  static final _id_empty = jniAccessors.getStaticMethodIDOf(_classRef, r"empty",
      r"()Lsoftware/amazon/smithy/model/validation/ValidatedResult;");

  /// from: static public software.amazon.smithy.model.validation.ValidatedResult<T> empty()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates an empty ValidatedResult with no value and no events.
  ///@param <T> The type of value in the result.
  ///@return Returns the created ValidatedResult.
  static ValidatedResult<$T> empty<$T extends jni.JObject>({
    required jni.JObjType<$T> T,
  }) {
    return $ValidatedResultType(T).fromRef(jniAccessors
        .callStaticMethodWithArgs(
            _classRef, _id_empty, jni.JniCallType.objectType, []).object);
  }

  static final _id_getValidationEvents = jniAccessors.getMethodIDOf(
      _classRef, r"getValidationEvents", r"()Ljava/util/List;");

  /// from: public java.util.List<software.amazon.smithy.model.validation.ValidationEvent> getValidationEvents()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the list of ValidationEvents associated with the result.
  ///@return Returns the validation events.
  jni.JObject getValidationEvents() {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_getValidationEvents,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_getValidationEvents1 = jniAccessors.getMethodIDOf(
      _classRef,
      r"getValidationEvents",
      r"(Lsoftware/amazon/smithy/model/validation/Severity;)Ljava/util/List;");

  /// from: public java.util.List<software.amazon.smithy.model.validation.ValidationEvent> getValidationEvents(software.amazon.smithy.model.validation.Severity severity)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get validation events of a particular severity.
  ///@param severity Severity to get.
  ///@return Returns a list of events with the given severity.
  jni.JObject getValidationEvents1(
    jni.JObject severity,
  ) {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference,
        _id_getValidationEvents1,
        jni.JniCallType.objectType,
        [severity.reference]).object);
  }

  static final _id_getResult = jniAccessors.getMethodIDOf(
      _classRef, r"getResult", r"()Ljava/util/Optional;");

  /// from: public java.util.Optional<T> getResult()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the optional result.
  ///@return Returns the optional result.
  jni.JObject getResult() {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference, _id_getResult, jni.JniCallType.objectType, []).object);
  }

  static final _id_unwrap =
      jniAccessors.getMethodIDOf(_classRef, r"unwrap", r"()Ljava/lang/Object;");

  /// from: public T unwrap()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the result, but throw if there are any ERROR events or if the
  /// result is empty.
  ///@return Returns the result.
  ///@throws ValidatedResultException if there are any ERROR events.
  ///@throws IllegalStateException if there is no result.
  $T unwrap() {
    return T.fromRef(jniAccessors.callMethodWithArgs(
        reference, _id_unwrap, jni.JniCallType.objectType, []).object);
  }

  static final _id_validate = jniAccessors.getMethodIDOf(
      _classRef, r"validate", r"()Ljava/util/Optional;");

  /// from: public java.util.Optional<T> validate()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the optional result, and throw if there are any ERROR events.
  ///@return Returns the optional result.
  ///@throws ValidatedResultException if there are any ERROR events.
  jni.JObject validate() {
    return const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
        reference, _id_validate, jni.JniCallType.objectType, []).object);
  }

  static final _id_isBroken =
      jniAccessors.getMethodIDOf(_classRef, r"isBroken", r"()Z");

  /// from: public boolean isBroken()
  ///
  /// Checks if the result has any error or danger events..
  ///@return Returns true if there are errors or unsuppressed dangers.
  bool isBroken() {
    return jniAccessors.callMethodWithArgs(
        reference, _id_isBroken, jni.JniCallType.booleanType, []).boolean;
  }
}

class $ValidatedResultType<$T extends jni.JObject>
    extends jni.JObjType<ValidatedResult<$T>> {
  final jni.JObjType<$T> T;

  const $ValidatedResultType(
    this.T,
  );

  @override
  String get signature =>
      r"Lsoftware/amazon/smithy/model/validation/ValidatedResult;";

  @override
  ValidatedResult<$T> fromRef(jni.JObjectPtr ref) =>
      ValidatedResult.fromRef(T, ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => Object.hash($ValidatedResultType, T);

  @override
  bool operator ==(Object other) {
    return other.runtimeType == $ValidatedResultType &&
        other is $ValidatedResultType &&
        T == other.T;
  }
}
