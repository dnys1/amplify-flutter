// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: overridden_fields
// ignore_for_file: unnecessary_cast
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "dart:isolate" show ReceivePort;
import "dart:ffi" as ffi;
import "package:jni/internal_helpers_for_jnigen.dart";
import "package:jni/jni.dart" as jni;

import "../Model.dart" as model_;
import "../../../../../_init.dart";

/// from: software.amazon.smithy.model.shapes.ModelSerializer
///
/// Serializes a Model to an ObjectNode.
///
/// The serialized value sorts all map key-value pairs so that they contain
/// a consistent key ordering, reducing noise in diffs based on
/// serialized model.
///
/// After serializing to an ObjectNode, the node can then be serialized
/// to formats like JSON, YAML, Ion, etc.
class ModelSerializer extends jni.JObject {
  @override
  late final jni.JObjType<ModelSerializer> $type = type;

  ModelSerializer.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $ModelSerializerType();
  static final _serialize = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("ModelSerializer__serialize")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public software.amazon.smithy.model.node.ObjectNode serialize(software.amazon.smithy.model.Model model)
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JObject serialize(
    model_.Model model,
  ) {
    return const jni.JObjectType()
        .fromRef(_serialize(reference, model.reference).object);
  }

  static final _builder =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "ModelSerializer__builder")
          .asFunction<jni.JniResult Function()>();

  /// from: static public software.amazon.smithy.model.shapes.ModelSerializer.Builder builder()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return Returns a builder used to create a ModelSerializer.
  static ModelSerializer_Builder builder() {
    return const $ModelSerializer_BuilderType().fromRef(_builder().object);
  }
}

class $ModelSerializerType extends jni.JObjType<ModelSerializer> {
  const $ModelSerializerType();

  @override
  String get signature =>
      r"Lsoftware/amazon/smithy/model/shapes/ModelSerializer;";

  @override
  ModelSerializer fromRef(jni.JObjectPtr ref) => ModelSerializer.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ModelSerializerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ModelSerializerType) &&
        other is $ModelSerializerType;
  }
}

/// from: software.amazon.smithy.model.shapes.ModelSerializer$Builder
///
/// Builder used to create ModelSerializer.
class ModelSerializer_Builder extends jni.JObject {
  @override
  late final jni.JObjType<ModelSerializer_Builder> $type = type;

  ModelSerializer_Builder.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $ModelSerializer_BuilderType();
  static final _metadataFilter = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "ModelSerializer_Builder__metadataFilter")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public software.amazon.smithy.model.shapes.ModelSerializer.Builder metadataFilter(java.util.function.Predicate<java.lang.String> metadataFilter)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Predicate that determines if a metadata is serialized.
  ///@param metadataFilter Predicate that accepts a metadata key.
  ///@return Returns the builder.
  ModelSerializer_Builder metadataFilter(
    jni.JObject metadataFilter,
  ) {
    return const $ModelSerializer_BuilderType()
        .fromRef(_metadataFilter(reference, metadataFilter.reference).object);
  }

  static final _shapeFilter = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "ModelSerializer_Builder__shapeFilter")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public software.amazon.smithy.model.shapes.ModelSerializer.Builder shapeFilter(java.util.function.Predicate<software.amazon.smithy.model.shapes.Shape> shapeFilter)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Predicate that determines if a shape and its traits are serialized.
  ///@param shapeFilter Predicate that accepts a shape.
  ///@return Returns the builder.
  ModelSerializer_Builder shapeFilter(
    jni.JObject shapeFilter,
  ) {
    return const $ModelSerializer_BuilderType()
        .fromRef(_shapeFilter(reference, shapeFilter.reference).object);
  }

  static final _includePrelude = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("ModelSerializer_Builder__includePrelude")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public software.amazon.smithy.model.shapes.ModelSerializer.Builder includePrelude(boolean includePrelude)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Enables or disables including the prelude in the serialized model.
  ///
  /// By default, the prelude is not included.
  ///
  /// This should nearly always be left at default, as per the spec the prelude is
  /// inherently part of every model, and so any Smithy implementation must build in
  /// an understanding of the prelude. Disabling this filter can be useful for those
  /// implementations to allow them to build their understanding of it from a JSON
  /// version of the prelude.
  ///@param includePrelude boolean indicating whether the prelude should be included or not.
  ///@return Returns the builder.
  ModelSerializer_Builder includePrelude(
    bool includePrelude,
  ) {
    return const $ModelSerializer_BuilderType()
        .fromRef(_includePrelude(reference, includePrelude ? 1 : 0).object);
  }

  static final _traitFilter = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "ModelSerializer_Builder__traitFilter")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public software.amazon.smithy.model.shapes.ModelSerializer.Builder traitFilter(java.util.function.Predicate<software.amazon.smithy.model.traits.Trait> traitFilter)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets a predicate that can be used to filter trait values from
  /// appearing in the serialized model.
  ///
  /// Note that this does not filter out trait definitions. It only filters
  /// out instances of traits from being serialized on shapes.
  ///@param traitFilter Predicate that filters out trait definitions.
  ///@return Returns the builder.
  ModelSerializer_Builder traitFilter(
    jni.JObject traitFilter,
  ) {
    return const $ModelSerializer_BuilderType()
        .fromRef(_traitFilter(reference, traitFilter.reference).object);
  }

  static final _version = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("ModelSerializer_Builder__version")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public software.amazon.smithy.model.shapes.ModelSerializer.Builder version(java.lang.String version)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the IDL version to serialize. Defaults to 2.0.
  ///
  /// Version "1.0" serialization cannot be used with \#includePrelude.
  ///@param version IDL version to set. Can be "1", "1.0", "2", or "2.0".
  ///                "1" and "2" are normalized to "1.0" and "2.0".
  ///@return Returns the builder.
  ModelSerializer_Builder version(
    jni.JString version,
  ) {
    return const $ModelSerializer_BuilderType()
        .fromRef(_version(reference, version.reference).object);
  }

  static final _build = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "ModelSerializer_Builder__build")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public software.amazon.smithy.model.shapes.ModelSerializer build()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ModelSerializer build() {
    return const $ModelSerializerType().fromRef(_build(reference).object);
  }
}

class $ModelSerializer_BuilderType
    extends jni.JObjType<ModelSerializer_Builder> {
  const $ModelSerializer_BuilderType();

  @override
  String get signature =>
      r"Lsoftware/amazon/smithy/model/shapes/ModelSerializer$Builder;";

  @override
  ModelSerializer_Builder fromRef(jni.JObjectPtr ref) =>
      ModelSerializer_Builder.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ModelSerializer_BuilderType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ModelSerializer_BuilderType) &&
        other is $ModelSerializer_BuilderType;
  }
}
