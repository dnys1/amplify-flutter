// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: overridden_fields
// ignore_for_file: unnecessary_cast
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "dart:isolate" show ReceivePort;
import "dart:ffi" as ffi;
import "package:jni/internal_helpers_for_jnigen.dart";
import "package:jni/jni.dart" as jni;

import "../Model.dart" as model_;

import "../shapes/ServiceShape.dart" as serviceshape_;
import "../../../../../_init.dart";

/// from: software.amazon.smithy.model.transform.ModelTransformer
///
/// Class used to transform Models.
class ModelTransformer extends jni.JObject {
  @override
  late final jni.JObjType<ModelTransformer> $type = type;

  ModelTransformer.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $ModelTransformerType();
  static final _create =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "ModelTransformer__create")
          .asFunction<jni.JniResult Function()>();

  /// from: static public software.amazon.smithy.model.transform.ModelTransformer create()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a ModelTransformer using ModelTransformerPlugin instances
  /// discovered using the {@code com.software.smithy.transform} class
  /// loader and any modules found in the module path.
  ///@return Returns the created ModelTransformer.
  static ModelTransformer create() {
    return const $ModelTransformerType().fromRef(_create().object);
  }

  static final _createWithPlugins = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "ModelTransformer__createWithPlugins")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public software.amazon.smithy.model.transform.ModelTransformer createWithPlugins(java.util.List<software.amazon.smithy.model.transform.ModelTransformerPlugin> plugins)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a ModelTransformer using a list of ModelTransformer plugins.
  ///@param plugins Plugins to use with the transformer.
  ///@return Returns the created ModelTransformer.
  static ModelTransformer createWithPlugins(
    jni.JList<jni.JObject> plugins,
  ) {
    return const $ModelTransformerType()
        .fromRef(_createWithPlugins(plugins.reference).object);
  }

  static final _createWithServiceProviders = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "ModelTransformer__createWithServiceProviders")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public software.amazon.smithy.model.transform.ModelTransformer createWithServiceProviders(java.lang.ClassLoader classLoader)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a ModelTransformer that finds ModelTransformerPlugin
  /// service providers using the given ClassLoader.
  ///@param classLoader ClassLoader used to find ModelTransformerPlugin instances.
  ///@return Returns the created ModelTransformer.
  static ModelTransformer createWithServiceProviders(
    jni.JObject classLoader,
  ) {
    return const $ModelTransformerType()
        .fromRef(_createWithServiceProviders(classLoader.reference).object);
  }

  static final _replaceShapes = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("ModelTransformer__replaceShapes")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public software.amazon.smithy.model.Model replaceShapes(software.amazon.smithy.model.Model model, java.util.Collection<? extends software.amazon.smithy.model.shapes.Shape> shapes)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Adds or replaces shapes into the model while ensuring that the model
  /// is in a consistent state.
  ///@param model Model to transform.
  ///@param shapes Shapes to add or replace in the model.base.
  ///@return Returns the transformed model.base.
  model_.Model replaceShapes(
    model_.Model model,
    jni.JObject shapes,
  ) {
    return const model_.$ModelType().fromRef(
        _replaceShapes(reference, model.reference, shapes.reference).object);
  }

  static final _removeShapes = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("ModelTransformer__removeShapes")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public software.amazon.smithy.model.Model removeShapes(software.amazon.smithy.model.Model model, java.util.Collection<? extends software.amazon.smithy.model.shapes.Shape> shapes)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Removes shapes from the model while ensuring that the model is in a
  /// consistent state.
  ///@param model Model to transform.
  ///@param shapes Shapes to add or replace in the model.base.
  ///@return Returns the transformed model.base.
  model_.Model removeShapes(
    model_.Model model,
    jni.JObject shapes,
  ) {
    return const model_.$ModelType().fromRef(
        _removeShapes(reference, model.reference, shapes.reference).object);
  }

  static final _removeShapesIf = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("ModelTransformer__removeShapesIf")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public software.amazon.smithy.model.Model removeShapesIf(software.amazon.smithy.model.Model model, java.util.function.Predicate<software.amazon.smithy.model.shapes.Shape> predicate)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Removes shapes from the model that match the given predicate.
  ///@param model Model to transform.
  ///@param predicate Predicate that accepts a shape and returns true to
  ///  remove it.
  ///@return Returns the transformed model.base.
  model_.Model removeShapesIf(
    model_.Model model,
    jni.JObject predicate,
  ) {
    return const model_.$ModelType().fromRef(
        _removeShapesIf(reference, model.reference, predicate.reference)
            .object);
  }

  static final _renameShapes = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("ModelTransformer__renameShapes")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public software.amazon.smithy.model.Model renameShapes(software.amazon.smithy.model.Model model, java.util.Map<software.amazon.smithy.model.shapes.ShapeId,software.amazon.smithy.model.shapes.ShapeId> renamed)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Renames shapes using ShapeId pairs while ensuring that the
  ///  transformed model is in a consistent state.
  ///
  ///  This transformer ensures that when an aggregate shape is renamed, all
  ///  members are updated in the model.
  ///@param model Model to transform.
  ///@param renamed Map of shapeIds
  ///@return Returns the transformed model.base.
  model_.Model renameShapes(
    model_.Model model,
    jni.JMap<jni.JObject, jni.JObject> renamed,
  ) {
    return const model_.$ModelType().fromRef(
        _renameShapes(reference, model.reference, renamed.reference).object);
  }

  static final _renameShapes1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("ModelTransformer__renameShapes1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public software.amazon.smithy.model.Model renameShapes(software.amazon.smithy.model.Model model, java.util.Map<software.amazon.smithy.model.shapes.ShapeId,software.amazon.smithy.model.shapes.ShapeId> renamed, java.util.function.Supplier<software.amazon.smithy.model.loader.ModelAssembler> modelAssemblerSupplier)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Renames shapes using ShapeId pairs while ensuring that the
  ///  transformed model is in a consistent state.
  ///
  ///  This transformer ensures that when an aggregate shape is renamed, all
  ///  members are updated in the model.
  ///@param model Model to transform.
  ///@param renamed Map of shapeIds
  ///@param modelAssemblerSupplier Supplier used to create ModelAssemblers in each transform.
  ///@return Returns the transformed model.
  model_.Model renameShapes1(
    model_.Model model,
    jni.JMap<jni.JObject, jni.JObject> renamed,
    jni.JObject modelAssemblerSupplier,
  ) {
    return const model_.$ModelType().fromRef(_renameShapes1(
            reference,
            model.reference,
            renamed.reference,
            modelAssemblerSupplier.reference)
        .object);
  }

  static final _filterShapes = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("ModelTransformer__filterShapes")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public software.amazon.smithy.model.Model filterShapes(software.amazon.smithy.model.Model model, java.util.function.Predicate<software.amazon.smithy.model.shapes.Shape> predicate)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Filters shapes out of the model that do not match the given predicate.
  ///
  /// This filter will never filter out shapes that are part of the
  /// prelude. Use the \#removeShapes method directly if you need
  /// to remove traits that are in the prelude.
  ///@param model Model to transform.
  ///@param predicate Predicate that filters shapes.
  ///@return Returns the transformed model.
  model_.Model filterShapes(
    model_.Model model,
    jni.JObject predicate,
  ) {
    return const model_.$ModelType().fromRef(
        _filterShapes(reference, model.reference, predicate.reference).object);
  }

  static final _filterTraits = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("ModelTransformer__filterTraits")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public software.amazon.smithy.model.Model filterTraits(software.amazon.smithy.model.Model model, java.util.function.BiPredicate<software.amazon.smithy.model.shapes.Shape,software.amazon.smithy.model.traits.Trait> predicate)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Filters traits out of the model that do not match the given predicate.
  ///
  /// The predicate function accepts the shape that a trait is attached to
  /// and the trait. If the predicate returns false, then the trait is
  /// removed from the shape.
  ///@param model Model to transform.
  ///@param predicate Predicate that accepts a (Shape, Trait) and returns
  ///  false if the trait should be removed.
  ///@return Returns the transformed model.base.
  model_.Model filterTraits(
    model_.Model model,
    jni.JObject predicate,
  ) {
    return const model_.$ModelType().fromRef(
        _filterTraits(reference, model.reference, predicate.reference).object);
  }

  static final _removeTraitsIf = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("ModelTransformer__removeTraitsIf")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public software.amazon.smithy.model.Model removeTraitsIf(software.amazon.smithy.model.Model model, java.util.function.BiPredicate<software.amazon.smithy.model.shapes.Shape,software.amazon.smithy.model.traits.Trait> predicate)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Filters traits out of the model that match a predicate function.
  ///
  /// The predicate function accepts the shape that a trait is attached to
  /// and the trait. If the predicate returns true, then the trait is removed
  /// from the shape.
  ///@param model Model to transform.
  ///@param predicate Predicate that accepts a (Shape, Trait) and returns
  ///  true if the trait should be removed.
  ///@return Returns the transformed model.base.
  model_.Model removeTraitsIf(
    model_.Model model,
    jni.JObject predicate,
  ) {
    return const model_.$ModelType().fromRef(
        _removeTraitsIf(reference, model.reference, predicate.reference)
            .object);
  }

  static final _filterMetadata = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("ModelTransformer__filterMetadata")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public software.amazon.smithy.model.Model filterMetadata(software.amazon.smithy.model.Model model, java.util.function.BiPredicate<java.lang.String,software.amazon.smithy.model.node.Node> predicate)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Filters out metadata key-value pairs from a model that do not match
  /// a predicate.
  ///@param model Model to transform.
  ///@param predicate A predicate that accepts a metadata key-value pair.
  ///  If the predicate returns true, then the metadata key-value pair is
  ///  kept. Otherwise, it is removed.
  ///@return Returns the transformed model.base.
  model_.Model filterMetadata(
    model_.Model model,
    jni.JObject predicate,
  ) {
    return const model_.$ModelType().fromRef(
        _filterMetadata(reference, model.reference, predicate.reference)
            .object);
  }

  static final _mapTraits = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("ModelTransformer__mapTraits")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public software.amazon.smithy.model.Model mapTraits(software.amazon.smithy.model.Model model, java.util.function.BiFunction<software.amazon.smithy.model.shapes.Shape,software.amazon.smithy.model.traits.Trait,software.amazon.smithy.model.traits.Trait> mapper)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Maps over all traits in the model using a mapping function that accepts
  /// the shape the trait is applied to, a trait, and returns a trait,
  /// possibly even a different kind of trait.
  ///
  /// An exception is thrown if a trait is returned that targets a
  /// different shape than the Shape passed into the mapper function.
  ///@param model Model to transform.
  ///@param mapper Mapping function that accepts a (Shape, Trait) and returns
  ///  the mapped Trait.
  ///@return Returns the transformed model.base.
  model_.Model mapTraits(
    model_.Model model,
    jni.JObject mapper,
  ) {
    return const model_.$ModelType().fromRef(
        _mapTraits(reference, model.reference, mapper.reference).object);
  }

  static final _mapTraits1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("ModelTransformer__mapTraits1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public software.amazon.smithy.model.Model mapTraits(software.amazon.smithy.model.Model model, java.util.List<java.util.function.BiFunction<software.amazon.smithy.model.shapes.Shape,software.amazon.smithy.model.traits.Trait,software.amazon.smithy.model.traits.Trait>> mappers)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Maps over all traits in the model using multiple mapping functions.
  ///
  /// Note: passing in a list of mappers is much more efficient than
  /// invoking {@code mapTraits} multiple times because it reduces the number
  /// of intermediate models that are needed to perform the transformation.
  ///@param model Model to transform.
  ///@param mappers Mapping functions that accepts a (Shape, Trait) and
  ///  returns the mapped Trait.
  ///@return Returns the transformed model.base.
  ///@see \#mapShapes(Model, Function) for more information.
  model_.Model mapTraits1(
    model_.Model model,
    jni.JList<jni.JObject> mappers,
  ) {
    return const model_.$ModelType().fromRef(
        _mapTraits1(reference, model.reference, mappers.reference).object);
  }

  static final _mapShapes = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("ModelTransformer__mapShapes")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public software.amazon.smithy.model.Model mapShapes(software.amazon.smithy.model.Model model, java.util.function.Function<software.amazon.smithy.model.shapes.Shape,software.amazon.smithy.model.shapes.Shape> mapper)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Maps over all shapes in the model using a mapping function, allowing
  /// shapes to be replaced with completely different shapes or slightly
  /// modified shapes.
  ///
  /// An exception is thrown if a mapper returns a shape with a different
  /// shape ID or a different type.
  ///@param model Model to transform.
  ///@param mapper Mapping function that accepts a shape and returns a shape
  ///  with the same ID.
  ///@return Returns the transformed model.base.
  model_.Model mapShapes(
    model_.Model model,
    jni.JObject mapper,
  ) {
    return const model_.$ModelType().fromRef(
        _mapShapes(reference, model.reference, mapper.reference).object);
  }

  static final _mapShapes1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("ModelTransformer__mapShapes1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public software.amazon.smithy.model.Model mapShapes(software.amazon.smithy.model.Model model, java.util.List<java.util.function.Function<software.amazon.smithy.model.shapes.Shape,software.amazon.smithy.model.shapes.Shape>> mappers)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Maps over all shapes in the model using multiple mapping functions.
  ///
  /// Note: passing in a list of mappers is much more efficient than
  /// invoking {@code mapShapes}  multiple times because it reduces the
  /// number of intermediate models that are needed to perform the
  /// transformation.
  ///@param model Model to transform.
  ///@param mappers Mapping functions that accepts a shape and returns a
  ///  shape with the same ID.
  ///@return Returns the transformed model.base.
  ///@see \#mapShapes(Model, Function) for more information.
  model_.Model mapShapes1(
    model_.Model model,
    jni.JList<jni.JObject> mappers,
  ) {
    return const model_.$ModelType().fromRef(
        _mapShapes1(reference, model.reference, mappers.reference).object);
  }

  static final _removeUnreferencedShapes = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "ModelTransformer__removeUnreferencedShapes")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public software.amazon.smithy.model.Model removeUnreferencedShapes(software.amazon.smithy.model.Model model)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Removes shapes (excluding service shapes) that are not referenced by
  /// any other shapes.
  ///@param model Model to transform.
  ///@return Returns the transformed model.base.
  model_.Model removeUnreferencedShapes(
    model_.Model model,
  ) {
    return const model_.$ModelType()
        .fromRef(_removeUnreferencedShapes(reference, model.reference).object);
  }

  static final _removeUnreferencedShapes1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "ModelTransformer__removeUnreferencedShapes1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public software.amazon.smithy.model.Model removeUnreferencedShapes(software.amazon.smithy.model.Model model, java.util.function.Predicate<software.amazon.smithy.model.shapes.Shape> keepFilter)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Removes shapes (excluding service shapes) that are not referenced by
  /// any other shapes.
  ///
  /// Shapes that are part of the prelude or that act as the shape of any
  /// trait, regardless of if the trait is in use in the model, are never
  /// considered unreferenced.
  ///@param model Model to transform.
  ///@param keepFilter Predicate function that accepts an unreferenced
  ///  shape and returns true to remove the shape or false to keep the shape
  ///  in the model.base.
  ///@return Returns the transformed model.base.
  model_.Model removeUnreferencedShapes1(
    model_.Model model,
    jni.JObject keepFilter,
  ) {
    return const model_.$ModelType().fromRef(_removeUnreferencedShapes1(
            reference, model.reference, keepFilter.reference)
        .object);
  }

  static final _removeUnreferencedTraitDefinitions = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "ModelTransformer__removeUnreferencedTraitDefinitions")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public software.amazon.smithy.model.Model removeUnreferencedTraitDefinitions(software.amazon.smithy.model.Model model)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Removes definitions for traits that are not used by any shape in the
  /// model.base.
  ///
  /// Trait definitions that are part of the prelude will not be removed.
  ///@param model Model to transform
  ///@return Returns the transformed model.base.
  model_.Model removeUnreferencedTraitDefinitions(
    model_.Model model,
  ) {
    return const model_.$ModelType().fromRef(
        _removeUnreferencedTraitDefinitions(reference, model.reference).object);
  }

  static final _removeUnreferencedTraitDefinitions1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "ModelTransformer__removeUnreferencedTraitDefinitions1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public software.amazon.smithy.model.Model removeUnreferencedTraitDefinitions(software.amazon.smithy.model.Model model, java.util.function.Predicate<software.amazon.smithy.model.shapes.Shape> keepFilter)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Removes trait definitions for traits that are not used by any shape
  /// in the model.
  ///
  /// Trait definitions that are part of the prelude will not be removed.
  ///@param model Model to transform
  ///@param keepFilter Predicate function that accepts an unreferenced trait
  ///  shape (that has the TraitDefinition trait) and returns true to
  ///  remove the definition or false to keep the definition in the model.base.
  ///@return Returns the transformed model.base.
  model_.Model removeUnreferencedTraitDefinitions1(
    model_.Model model,
    jni.JObject keepFilter,
  ) {
    return const model_.$ModelType().fromRef(
        _removeUnreferencedTraitDefinitions1(
                reference, model.reference, keepFilter.reference)
            .object);
  }

  static final _scrubTraitDefinitions = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "ModelTransformer__scrubTraitDefinitions")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public software.amazon.smithy.model.Model scrubTraitDefinitions(software.amazon.smithy.model.Model model)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Removes all trait definitions from a model and all shapes that are
  /// only connected to the graph either directly or transitively by a
  /// trait definition shape.
  ///
  /// This can be useful when serializing a Smithy model to a format that
  /// does not include trait definitions and the shapes used by trait definitions
  /// would have no meaning (e.g., OpenAPI).
  ///@param model Model to transform.
  ///@return Returns the transformed model.base.
  model_.Model scrubTraitDefinitions(
    model_.Model model,
  ) {
    return const model_.$ModelType()
        .fromRef(_scrubTraitDefinitions(reference, model.reference).object);
  }

  static final _scrubTraitDefinitions1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "ModelTransformer__scrubTraitDefinitions1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public software.amazon.smithy.model.Model scrubTraitDefinitions(software.amazon.smithy.model.Model model, java.util.function.Predicate<software.amazon.smithy.model.shapes.Shape> keepFilter)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Removes trait definitions from a model and all shapes that are
  /// only connected to the graph either directly or transitively by a
  /// trait definition shape.
  ///
  /// This can be useful when serializing a Smithy model to a format that
  /// does not include trait definitions and the shapes used by trait definitions
  /// would have no meaning (e.g., OpenAPI).
  ///@param model Model to transform.
  ///@param keepFilter Predicate function that accepts an trait shape (that
  ///  has the TraitDefinition trait) and returns true to remove the
  ///  definition or false to keep the definition in the model.
  ///@return Returns the transformed model.
  model_.Model scrubTraitDefinitions1(
    model_.Model model,
    jni.JObject keepFilter,
  ) {
    return const model_.$ModelType().fromRef(_scrubTraitDefinitions1(
            reference, model.reference, keepFilter.reference)
        .object);
  }

  static final _getModelWithoutTraitShapes = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "ModelTransformer__getModelWithoutTraitShapes")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public software.amazon.smithy.model.Model getModelWithoutTraitShapes(software.amazon.smithy.model.Model model)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets all shapes from a model where shapes that define traits or shapes
  /// that are only used as part of a trait definition have been removed.
  ///@param model Model that contains shapes.
  ///@return Returns a model that contains matching shapes.
  model_.Model getModelWithoutTraitShapes(
    model_.Model model,
  ) {
    return const model_.$ModelType().fromRef(
        _getModelWithoutTraitShapes(reference, model.reference).object);
  }

  static final _getModelWithoutTraitShapes1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "ModelTransformer__getModelWithoutTraitShapes1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public software.amazon.smithy.model.Model getModelWithoutTraitShapes(software.amazon.smithy.model.Model model, java.util.function.Predicate<software.amazon.smithy.model.shapes.Shape> keepFilter)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets all shapes from a model where shapes that define traits or shapes
  /// that are only used as part of a trait definition have been removed.
  ///@param model Model that contains shapes.
  ///@param keepFilter Predicate function that accepts a trait shape (that
  ///  has the TraitDefinition trait) and returns true to remove the
  ///  definition or false to keep the definition in the model.
  ///@return Returns a model that contains matching shapes.
  model_.Model getModelWithoutTraitShapes1(
    model_.Model model,
    jni.JObject keepFilter,
  ) {
    return const model_.$ModelType().fromRef(_getModelWithoutTraitShapes1(
            reference, model.reference, keepFilter.reference)
        .object);
  }

  static final _sortMembers = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("ModelTransformer__sortMembers")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public software.amazon.smithy.model.Model sortMembers(software.amazon.smithy.model.Model model, java.util.Comparator<software.amazon.smithy.model.shapes.MemberShape> comparator)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Reorders the members of structure and union shapes using the given
  /// Comparator.
  ///
  /// Note that by default, Smithy models retain the order in which
  /// members are defined in the model. However, in programming languages
  /// where this isn't important, it may be desirable to order members
  /// alphabetically or using some other kind of order.
  ///@param model Model that contains shapes.
  ///@param comparator Comparator used to order members of unions and structures.
  ///@return Returns a model that contains matching shapes.
  model_.Model sortMembers(
    model_.Model model,
    jni.JObject comparator,
  ) {
    return const model_.$ModelType().fromRef(
        _sortMembers(reference, model.reference, comparator.reference).object);
  }

  static final _changeShapeType = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("ModelTransformer__changeShapeType")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public software.amazon.smithy.model.Model changeShapeType(software.amazon.smithy.model.Model model, java.util.Map<software.amazon.smithy.model.shapes.ShapeId,software.amazon.smithy.model.shapes.ShapeType> shapeToType)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Changes the type of each given shape.
  ///
  /// The following transformations are permitted:
  ///
  /// <ul>
  ///     <li>Any simple type to any simple type</li>
  ///     <li>List to set</li>
  ///     <li>Set to list</li>
  ///     <li>Structure to union</li>
  ///     <li>Union to structure</li>
  /// </ul>
  ///@param model Model to transform.
  ///@param shapeToType Map of shape IDs to the new type to use for the shape.
  ///@return Returns the transformed model.
  ///@throws ModelTransformException if an incompatible type transform is attempted.
  model_.Model changeShapeType(
    model_.Model model,
    jni.JMap<jni.JObject, jni.JObject> shapeToType,
  ) {
    return const model_.$ModelType().fromRef(
        _changeShapeType(reference, model.reference, shapeToType.reference)
            .object);
  }

  static final _changeShapeType1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("ModelTransformer__changeShapeType1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public software.amazon.smithy.model.Model changeShapeType(software.amazon.smithy.model.Model model, java.util.Map<software.amazon.smithy.model.shapes.ShapeId,software.amazon.smithy.model.shapes.ShapeType> shapeToType, software.amazon.smithy.model.transform.ChangeShapeTypeOption[] changeShapeTypeOptions)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Changes the type of each given shape.
  ///
  /// The following transformations are permitted:
  ///
  /// <ul>
  ///     <li>Any simple type to any simple type</li>
  ///     <li>List to set</li>
  ///     <li>Set to list</li>
  ///     <li>Structure to union</li>
  ///     <li>Union to structure</li>
  /// </ul>
  ///@param model Model to transform.
  ///@param shapeToType Map of shape IDs to the new type to use for the shape.
  ///@param changeShapeTypeOptions An array of options to enable when changing types.
  ///@return Returns the transformed model.
  ///@throws ModelTransformException if an incompatible type transform is attempted.
  model_.Model changeShapeType1(
    model_.Model model,
    jni.JMap<jni.JObject, jni.JObject> shapeToType,
    jni.JArray<jni.JObject> changeShapeTypeOptions,
  ) {
    return const model_.$ModelType().fromRef(_changeShapeType1(
            reference,
            model.reference,
            shapeToType.reference,
            changeShapeTypeOptions.reference)
        .object);
  }

  static final _changeStringEnumsToEnumShapes = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "ModelTransformer__changeStringEnumsToEnumShapes")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public software.amazon.smithy.model.Model changeStringEnumsToEnumShapes(software.amazon.smithy.model.Model model, boolean synthesizeEnumNames)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Changes each compatible string shape with the enum trait to an enum shape.
  ///
  /// A member will be created on the shape for each entry in the EnumTrait.
  ///
  /// When the enum definition from the enum trait has been marked as deprecated, or
  /// tagged as "internal", the corresponding enum shape member will be marked with the
  /// DeprecatedTrait or InternalTrait accordingly.
  ///@param model Model to transform.
  ///@param synthesizeEnumNames Whether enums without names should have names synthesized if possible.
  ///@return Returns the transformed model.
  model_.Model changeStringEnumsToEnumShapes(
    model_.Model model,
    bool synthesizeEnumNames,
  ) {
    return const model_.$ModelType().fromRef(_changeStringEnumsToEnumShapes(
            reference, model.reference, synthesizeEnumNames ? 1 : 0)
        .object);
  }

  static final _changeStringEnumsToEnumShapes1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "ModelTransformer__changeStringEnumsToEnumShapes1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public software.amazon.smithy.model.Model changeStringEnumsToEnumShapes(software.amazon.smithy.model.Model model)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Changes each compatible string shape with the enum trait to an enum shape.
  ///
  /// A member will be created on the shape for each entry in the EnumTrait.
  ///
  /// Strings with enum traits that don't define names are not converted.
  ///@param model Model to transform.
  ///@return Returns the transformed model.
  model_.Model changeStringEnumsToEnumShapes1(
    model_.Model model,
  ) {
    return const model_.$ModelType().fromRef(
        _changeStringEnumsToEnumShapes1(reference, model.reference).object);
  }

  static final _downgradeEnums = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("ModelTransformer__downgradeEnums")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public software.amazon.smithy.model.Model downgradeEnums(software.amazon.smithy.model.Model model)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Changes each enum shape to a string shape and each intEnum to an integer.
  ///@param model Model to transform.
  ///@return Returns the transformed model.
  model_.Model downgradeEnums(
    model_.Model model,
  ) {
    return const model_.$ModelType()
        .fromRef(_downgradeEnums(reference, model.reference).object);
  }

  static final _copyServiceErrorsToOperations = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "ModelTransformer__copyServiceErrorsToOperations")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public software.amazon.smithy.model.Model copyServiceErrorsToOperations(software.amazon.smithy.model.Model model, software.amazon.smithy.model.shapes.ServiceShape forService)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Copies the errors defined on the given service onto each operation bound to the
  /// service, effectively flattening service error inheritance.
  ///@param model Model to modify.
  ///@param forService Service shape to use as the basis for copying errors to operations.
  ///@return Returns the transformed model.
  model_.Model copyServiceErrorsToOperations(
    model_.Model model,
    serviceshape_.ServiceShape forService,
  ) {
    return const model_.$ModelType().fromRef(_copyServiceErrorsToOperations(
            reference, model.reference, forService.reference)
        .object);
  }

  static final _createDedicatedInputAndOutput = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "ModelTransformer__createDedicatedInputAndOutput")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public software.amazon.smithy.model.Model createDedicatedInputAndOutput(software.amazon.smithy.model.Model model, java.lang.String inputSuffix, java.lang.String outputSuffix)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Updates the model so that every operation has a dedicated input shape marked
  /// with the {@code input} trait and output shape marked with the {@code output}
  /// trait, and the targeted shapes all have a consistent shape name of
  /// OperationName + {@code inputSuffix} / {@code outputSuffix} depending on the
  /// context.
  ///
  /// If an operation's input already targets a shape marked with the {@code input}
  /// trait, then the existing input shape is used as input, though the shape will
  /// be renamed if it does not use the given {@code inputSuffix}. If an operation's
  /// output already targets a shape marked with the {@code output} trait, then the
  /// existing output shape is used as output, though the shape will be renamed if it
  /// does not use the given {@code outputSuffix}.
  ///
  /// If the operation's input shape starts with the name of the operation and is
  /// only used throughout the model as the input of the operation, then it is updated
  /// to have the {@code input} trait, and the name remains unaltered.
  ///
  /// If the operation's output shape starts with the name of the operation and is
  /// only used throughout the model as the output of the operation, then it is updated
  /// to have the {@code output} trait, and the name remains unaltered.
  ///
  /// If the operation's input shape does not start with the operation's name or
  /// is used in other places throughout the model, a copy of the targeted input
  /// structure is created, the name of the shape becomes OperationName + {@code inputSuffix},
  /// and the {@code input} trait is added to the shape. The operation is then updated
  /// to target the created shape, and the original shape is left as-is in the model.
  ///
  /// If the operation's output shape does not start with the operation's name or
  /// is used in other places throughout the model, a copy of the targeted output
  /// structure is created, the name of the shape becomes OperationName + {@code outputSuffix},
  /// and the {@code output} trait is added to the shape. The operation is then updated
  /// to target the created shape, and the original shape is left as-is in the model.
  ///
  /// If a naming conflict occurs while attempting to create a new shape, then
  /// the default naming conflict resolver will attempt to name the shape
  /// OperationName + "Operation" + {@code inputSuffix} / {@code outputSuffix}
  /// depending on the context. If the name is _still_ in conflict with other
  /// shapes in the model, then a ModelTransformException is thrown.
  ///
  /// Any time a shape is renamed, the original shape ID of the shape is captured
  /// on the shape using the synthetic OriginalShapeIdTrait. This might be
  /// useful for protocols that need to serialize input and output shape names.
  ///@param model Model to update.
  ///@param inputSuffix Suffix to append to dedicated input shapes (e.g., "Input").
  ///@param outputSuffix Suffix to append to dedicated input shapes (e.g., "Output").
  ///@return Returns the updated model.
  ///@throws ModelTransformException if an input or output shape name conflict occurs.
  model_.Model createDedicatedInputAndOutput(
    model_.Model model,
    jni.JString inputSuffix,
    jni.JString outputSuffix,
  ) {
    return const model_.$ModelType().fromRef(_createDedicatedInputAndOutput(
            reference,
            model.reference,
            inputSuffix.reference,
            outputSuffix.reference)
        .object);
  }

  static final _flattenAndRemoveMixins = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "ModelTransformer__flattenAndRemoveMixins")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public software.amazon.smithy.model.Model flattenAndRemoveMixins(software.amazon.smithy.model.Model model)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Flattens mixins out of the model and removes them from the model.
  ///@param model Model to flatten.
  ///@return Returns the flattened model.
  model_.Model flattenAndRemoveMixins(
    model_.Model model,
  ) {
    return const model_.$ModelType()
        .fromRef(_flattenAndRemoveMixins(reference, model.reference).object);
  }

  static final _addClientOptional = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("ModelTransformer__addClientOptional")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public software.amazon.smithy.model.Model addClientOptional(software.amazon.smithy.model.Model model, boolean applyWhenNoDefaultValue)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add the clientOptional trait to members that are effectively nullable because
  /// they are part of a structure marked with the input trait or they aren't required
  /// and don't have a default trait.
  ///@param model Model to transform.
  ///@param applyWhenNoDefaultValue Set to true to add clientOptional to members that target
  ///                                shapes with no zero value (e.g., structure and union).
  ///@return Returns the transformed model.
  model_.Model addClientOptional(
    model_.Model model,
    bool applyWhenNoDefaultValue,
  ) {
    return const model_.$ModelType().fromRef(_addClientOptional(
            reference, model.reference, applyWhenNoDefaultValue ? 1 : 0)
        .object);
  }

  static final _downgradeToV1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("ModelTransformer__downgradeToV1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public software.amazon.smithy.model.Model downgradeToV1(software.amazon.smithy.model.Model model)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Removes Smithy IDL 2.0 features from a model that are not strictly necessary to keep for consistency with the
  /// rest of Smithy.
  ///
  /// This transformer is lossy, and converts enum shapes to string shapes with the enum trait, intEnum shapes to
  /// integer shapes, flattens and removes mixins, removes properties from resources, and removes default traits that
  /// have no impact on IDL 1.0 semantics (i.e., default traits on structure members set to something other than null,
  /// or default traits on any other shape that are not the zero value of the shape of a 1.0 model).
  ///@param model Model to downgrade.
  ///@return Returns the downgraded model.
  model_.Model downgradeToV1(
    model_.Model model,
  ) {
    return const model_.$ModelType()
        .fromRef(_downgradeToV1(reference, model.reference).object);
  }
}

class $ModelTransformerType extends jni.JObjType<ModelTransformer> {
  const $ModelTransformerType();

  @override
  String get signature =>
      r"Lsoftware/amazon/smithy/model/transform/ModelTransformer;";

  @override
  ModelTransformer fromRef(jni.JObjectPtr ref) => ModelTransformer.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ModelTransformerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ModelTransformerType) &&
        other is $ModelTransformerType;
  }
}
